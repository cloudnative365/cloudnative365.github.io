---
title:  云原生的身世之谜
categories: cloudnative
permalink: 2022-03-19-cloudnative.html
tags: [news]
typora-copy-images-to: ./pics/cloudnative
typora-root-url: ../cloudnative365.github.io
---

## 1 什么是云原生

云原生的英文名字叫做CloudNative，在如今这个云原生概念火彼岸大江南北黄河两岸的时代，如果你还不知道云原生是什么，那可就真的过时了。

![What Is Cloud Native Computing?. Many employers want developers who have… |  by David Chung | The Startup | Medium](/../_posts/pics/cloudnative/1*hmT21vmPb0MLgFoWov50VA.png)

大家在工作中经常会听到云原生这个词，但是每个人对于云原生的解读可能都是不一样的。这也就是为什么即使你查阅所有资料，也没办法得到准确定义的原因。因为定义仅仅是定义而已，定义可以被定义，也可以取消定义，也可以被任何人定义，这也是为什么这个概念非常火热的原因，大家都想给出一个准确的定义，而百家争鸣的情况，恰恰可以让这个话题更加的火热，从而，让某些深谋远虑的公司获得更大的关注。

### 1.1. 云原生概念的产生

最早的是由Pivotal的攻城狮Matt Stine在2013年首次提出的一个概念。

![file](/../_posts/pics/cloudnative/222c485b6dcc44762d65201584886558.png)

在2015年，他又在<Migrating to Cloud-Native Application Architectures>中对于cloud native做了早期的定义，包括12因素、微服务、自敏捷架构、基于API协作和扛脆弱性。

![我们为什么需要云原生？-黑马观点-黑马澜狮官网-苏州网站建设,网页设计制作,百度优化,谷歌SEO推广公司](/../_posts/pics/cloudnative/v2_708f6a36c370483fb15e8dc4eb9f825b_img_000.png)

在2017年，他在接受InfoQ采访时，又将云原生架构归纳为模块化、可观察、可部署、可测试、可替换、可处理这6个特质。最后，Pivotal将云原生归纳为四个特征：**DevOps+持续交付+微服务+容器**。

![img](/../_posts/pics/cloudnative/v2-7913f6e74f38682804d36f88c4fb4882_720w.jpg)

### 1.2. 渔翁得利

2015年云原生计算基金会（CNCF）成立，CNCF掺和进来后，最初把云原生定义为包括：容器化封装+自动化管理+面向微服务；到了2018年，CNCF又更新了云原生的定义，把服务网格(Service Mesh)和声明式API给加了进来。

### 1.3. 结论

**总而言之，符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。**

它是一个思想的集合，包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。Cloud Native既包含技术（微服务，敏捷基础设施），也包含管理（DevOps，持续交付，康威定律，重组等）。Cloud Native也可以说是一系列Cloud技术、企业管理方法的集合。

## 2. 四要素

**微服务**：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。

微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。

**容器化**：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。

**DevOps**：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。

**持续交付**：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。

![img](/../_posts/pics/cloudnative/v2-50c32ca3a8189d37c3ace9febc45b0a0_720w.jpg)



## 3. 渔翁公司与他的技术发展的历史

![file](/../_posts/pics/cloudnative/222e0dfcf7f9f4c7794f201584886745.png)

- 2004 年— 2007 年，Google 已在内部大规模地使用像 Cgroups 这样的容器技术；
- 2008 年，Google 将 Cgroups 合并进入了 Linux 内核主干，形成了早期的容器技术LXC
- 2013 年，Docker 项目正式发布。
- 2014 年，Kubernetes 项目也正式发布。这样的原因也非常容易理解，因为有了容器和 Docker 之后，就需要有一种方式去帮助大家方便、快速、优雅地管理这些容器，这就是 Kubernetes 项目的初衷。在 Google 发布了 Kubernetes 之后，这个项目的发展速度非常之快。
- 2015 年，由Google、Redhat 以及微软等大型云计算厂商以及一些开源公司共同牵头成立了 CNCF 云原生基金会。CNCF 成立之初，就有 22 个创始会员，而且 Kubernetes 也成为了 CNCF 托管的第一个开源项目。在这之后，CNCF 的发展速度非常迅猛；而同年，OCI（开放容器标准）也公布了。
- 2017 年，CNCF 达到 170 个成员和 14 个基金项目；而另外两个竞争对手，mesos和docker也在同年宣布支持kubernetes。
- 2018 年，CNCF 成立三周年有了 195 个成员，19 个基金会项目和 11 个孵化项目，如此之快的发展速度在整个云计算领域都是非常罕见的。

## 4. 云原生技术的现状

CNCF 有一张云原生[全景图](https://landscape.cncf.io/images/landscape.png)在这个全景图里已经有 200 多个项目和产品了，这些项目和产品也都是和 CNCF 的观点所契合的。 这个全景图是在的太大了，每次KubeCon大会的时候，上台演讲的人都会担心屏幕无法把全景图显示出来。这个全景图我在加载的时候用了1分多钟，大小是MB。上面密密麻麻的名字会让有密集恐惧症的人立马起一身的鸡皮疙瘩。为了照顾大家的网速，我这里给大家做一个缩小版的截图，但是有兴趣的朋友一定要看一看，上面有非常多的logo都是我们耳闻能详的软件。如果你想成为一个云原生架构师，那么上面的软件起码要知道是干什么用的，如果说自己是资深的架构师，起码要亲自部署过才敢这么称呼自己吧。

![file](/../_posts/pics/cloudnative/222ee31039bbf936b7e9901584889508.png)

所以如果以这张全景图作为背景，加以思考就会发现，我们今天所讨论的云原生其实主要谈论了以下几点：

- 云原生基金会 云原生基金会，英文缩写叫CNCF，全称是Cloud Native Computing Foundation，是目前云计算领域最成功的开源基金会之一，是kubenetes，containerd，prometheus等著名开源项目的托管基金会。
- 云原生技术社区 CNCF目前托管的30多个正式项目共同构成了现代云计算生态的基石，其中kubernetes项目是全世界第四活跃的开源项目。
- 云原生技术产业 全球各大公有云厂商和100多个技术创业公司持续的投入，总体市场与2021年逼近1000亿美元。国内的互联网企业纷纷全面投入云计算行业。

## 5. 回顾2019年

2019 年正是云原生时代的关键节点，为什么这么说？我们这里就为大家简单梳理一下。

从 2013 年 Docker 项目发布开始说起，Docker 项目的发布使得全操作系统语义的沙盒技术唾手可得，使得用户能够更好地、更完整地打包自己的应用，使得开发者可以轻而易举的获得了一个应用的最小可运行单位，而不需要依赖任何 PaaS 能力。这对经典 PaaS 产业其实是一个“降维打击”。

2014 年的时候，Kubernetes 项目发布，其意义在于 Google 将内部的 Borg/Omega 系统思想借助开源社区实现了“重生”，并且提出了“容器设计模式”的思想。而 Google 之所以选择间接开源 Kubernetes 而不是直接开源 Borg 项目，其实背后的原因也比较容易理解：Borg/Omega 这样的系统太复杂了，是没办法提供给 Google 之外的人使用，但是 Borg/Omega 这样的设计思想却可以借助 Kubernetes 让大家接触到，这也是开源 Kubernetes 的重要背景。

这样到了 2015 年到 2016 年，就到了容器编排“三国争霸”的时代，当时 Docker、Swarm、Mesos、Kubernetes 都在容器编排领域展开角逐，他们竞争的原因其实也比较容易理解， 那就是 Docker 或者容器本身的价值虽然大，但是如果想要让其产生商业价值或者说对云的价值，那么就一定需要在编排上面占据一个有利的位置。

Swarm 和 Mesos 的特点，那就是各自只在生态和技术方面比较强，其中，Swarm 更偏向于生态，而 Mesos 技术更强一些。相比之下， Kubernetes 则兼具了两者优势，最终在 2017 年“三国争霸”的局面中得以胜出，成为了当时直到现在的容器编排标准。这一过程的代表性事件就是 Docker 公司宣布在核心产品中内置了 Kubernetes 服务，并且 Swarm 项目逐渐停止维护。

到了 2018 年的时候，云原生技术理念开始逐渐萌芽，这是因为此时 Kubernetes 以及容器都成为了云厂商的既定标准，以“云”为核心的软件研发思想逐步形成。

而到了 2019 年，云原生技术普及元年。首先大家可以看到，在 2019 年，阿里巴巴宣布要全面上云，而且“上云就要上云原生”。我们还可以看到，以“云”为核心的软件研发思想，正逐步成为所有开发者的默认选项。像 Kubernetes 等云原生技术正在成为技术人员的必修课，大量的工作岗位正在涌现出来。这种背景下，“会 Kubernetes”已经远远不够了，“懂 Kubernetes”、“会云原生架构”的重要性正日益凸显出来。 从 2019 年开始，云原生技术将会大规模普及，这也是为什么大家都要在这个时间点上学习和投资云原生技术的重要原因。

## 6. 云原生的技术范畴（Landscape）

![file](/../_posts/pics/cloudnative/222ba706de12fbca470ab01584889205.png)

1. 容器化。目前最流行的容器化技术是Docker，你可以将任意大小的应用程序和依赖项，甚至在模拟器上运行的一些程序，都进行容器化。随着时间的推移，你还可以对应用程序进行分割，并将未来的功能编写为微服务。
2. CI/CD（持续集成和持续发布）。创建CI/CD环境，从而使源代码上的任意修改，都能够自动通过容器进行编译、测试，并被部署到预生产甚至生产环境中。
3. 应用编排。Kubernetes是目前市场上应用编排领域被最广泛应用的工具，Helm Charts可以用来帮助应用开发和发布者用于升级Kubernetes上运行的应用。
4. 监控和分析。在这一步中，用户需要为平台选择监控、日志以及跟踪的相关工具，例如将Prometheus用于监控、Fluentd用于日志、Jaeger用于整个应用调用链的跟踪。
5. 服务代理、发现和治理。CoreDNS、Envoy和LInkerd可以分别用于服务发现和服务治理，提供服务的健康检查、请求路由、和负载均衡等功能。
6. 网络。Calico、Flannel以及Weave Net等软件用于提供更灵活的网络功能。
7. 分布式数据库和存储。分布式数据库可以提供更好的弹性和伸缩性能，但同时需要专业的容器存储予以支持。
8. 流和消息处理。当应用需要比JSON-REST这个模式更高的性能时，可以考虑使用gRPC或者NATS。gRPC是一个通用的RPC（远程调用）框架（类似各种框架中的RPC调用），NATS是一个发布/订阅和负载均衡的消息队列系统。
9. 容器镜像库和运行环境。Harbor是目前最受欢迎的容器镜像库，同时，你也可以选择使用不同的容器运行环境用于运行容器程序。
10. 软件发布。最后可以借助Notary等软件用于软件的安全发布。

## 7. 云原生思想的两个理论

- 第一个理论基础是：不可变基础设施。这一点目前是通过容器镜像来实现的，其含义就是应用的基础设施应该是不可变的，是一个自包含、自描述可以完全在不同环境中迁移的东西；
- 第二个理论基础就是：云应用编排理论。当前的实现方式就是 Google 所提出来的“容器设计模式”，这也是本系列课程中的 Kubernetes 部分所需主要讲解的内容。

## 8. 基础设施向云演进的过程

首先为大家介绍一下“不可变基础设施”的概念。其实，应用所依赖的基础设施也在经历一个向云演进的过程，举例而言，对于传统的应用基础设施而言，其实往往是可变的。

大家可能经常会干这样一件事情，比如需要发布或者更新一个软件，那么流程大致是这样的，先通过 SSH 连到服务器，然后手动升级或者降级软件包，逐个调整服务器上的配置文件，并且将新代码直接都部署到现有服务器上。因此，这套基础设施会不断地被调整和修改。

但是在云上，对“云”友好的应用基础设施是不可变的。

这种场景下的上述更新过程会这么做：一旦应用部署完成之后，那么这套应用基础设施就不会再修改了。如果需要更新，那么需要现更改公共镜像来构建新服务直接替换旧服务。而我们之所以能够实现直接替换，就是因为容器提供了自包含的环境（包含应用运行所需的所有依赖）。所以对于应用而言，完全不需要关心容器发生了什么变化，只需要把容器镜像本身修改掉就可以了。因此，对于云友好的基础设施是随时可以替换和更换的，这就是因为容器具有敏捷和一致性的能力，也就是云时代的应用基础设施。

所以，总结而言，云时代的基础设施就像是可以替代的“牲口”，可以随时替换；而传统的基础设施则是独一无二的“宠物”，需要细心呵护，这就体现出了云时代不可变基础设施的优点。

## 9. 基础设施向云演进的意义

所以，像这样的基础设施向“不可变”演进的过程，为我们提供了两个非常重要的优点。

1、基础设施的一致性和可靠性。同样一个镜像，无论是在美国打开，在中国打开，还是在印度打开都是一样的。并且其中的 OS 环境对于应用而言都是一致的。而对于应用而言，它就不需要关心容器跑在哪里，这就是基础设施一致性非常重要的一个特征。

2、这样的镜像本身就是自包含的，其包含了应用运行所需要的所有依赖，因此也可以漂移到云上的任何一个位置。

此外，云原生的基础设施还提供了简单、可预测的部署和运维能力。由于现在有了镜像，应用还是自描述的，通过镜像运行起来的整个容器其实可以像 Kubernetes 的 Operator 技术一样将其做成自运维的，所以整个应用本身都是自包含的行为，使得其能够迁移到云上任何一个位置。这也使得整个流程的自动化变得非常容易。

应用本身也可以更好地扩容，从 1 个实例变成 100 个实例，进而变成 1 万个实例，这个过程对于容器化后的应用没有任何特殊的。最后，我们这时也能够通过不可变的基础设施来地快速周围的管控系统和支撑组件。因为，这些组件本身也是容器化的，是符合不可变基础设施这样一套理论的组件。

以上就是不可变基础设施为用户带来的最大的优点。

## 10. 云原生关键技术点

当我们回过头来看云原生关键技术点或者说它所依赖的技术理论的时候，可以看到主要有这样的四个方向：

1. 如何构建自包含、可定制的应用镜像；
2. 能不能实现应用快速部署与隔离能力；
3. 应用基础设施创建和销毁的自动化管理；
4. 可复制的管控系统和支撑组件。



## 总结

“未来的软件一定是生长于云上的”这是云原生理念的最核心假设。而所谓“云原生”，实际上就是在定义一条能够让应用最大程度利用云的能力、发挥云的价值的最佳路径。在这条路径上，脱离了“应用”这个载体，“云原生”就无从谈起；容器技术，则是将这个理念落地、将软件交付的革命持续进行下去的重要手段之一。
