<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>HELM | cloudnative365.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="HELM" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/keynotes_L2_advanced_1_kubernetes_1_CKA_14_HELM.html" />
<meta property="og:url" content="http://localhost:4000/keynotes_L2_advanced_1_kubernetes_1_CKA_14_HELM.html" />
<meta property="og:site_name" content="cloudnative365.github.io" />
<script type="application/ld+json">
{"headline":"HELM","url":"http://localhost:4000/keynotes_L2_advanced_1_kubernetes_1_CKA_14_HELM.html","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=481468f1311b237dbb8ec4fec8c1099b04cbcc76">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">cloudnative365.github.io</a></h1>
      

      <h2 id="learning-objectives">Learning Objectives</h2>

<p>By the end of this chapter, you should be able to:</p>

<ul>
  <li>Examine easy Kubernetes deployments using the Helm package manager.</li>
  <li>Understand the Chart template used to describe what application to deploy.</li>
  <li>Discuss how Tiller creates the Deployment based on the Chart.</li>
  <li>Initialize Helm in a cluster.</li>
</ul>

<h2 id="helm">HELM</h2>

<h3 id="deploying-complex-applications">Deploying Complex Applications</h3>

<p>We have used Kubernetes tools to deploy simple Docker applications. Starting with the v1.4 release, the goal was to have a canonical location for software. Helm is similar to a package manager like <strong>yum</strong> or <strong>apt</strong>, with a chart being similar to a package. Helm v3 is significantly different than v2.</p>

<p>A typical containerized application will have several manifests. Manifests for deployments, services, and ConfigMaps. You will probably also create some secrets, Ingress, and other objects. Each of these will need a manifest.</p>

<p>With Helm, you can package all those manifests and make them available as a single tarball. You can put the tarball in a repository, search that repository, discover an application, and then, with a single command, deploy and start the entire application.</p>

<p>The server runs in your Kubernetes cluster, and your client is local, even a local laptop. With your client, you can connect to multiple repositories of applications.</p>

<p>You will also be able to upgrade or roll back an application easily from the command line.</p>

<h3 id="helm-v2-and-tiller">Helm v2 and Tiller</h3>

<p>The helm tool packages a Kubernetes application using a series of YAML files into a chart, or package. This allows for simple sharing between users, tuning using a templating scheme, as well as provenance tracking, among other things.</p>

<p><img src="/pages/keynotes/L2_advanced/1_CKA/pics/14_HELM/zgxbwiuexxtg-BasicFlow-HelmandTiller.png" alt="Basic Flow - Helm and Tiller" /></p>

<p><strong>Basic Helm and Tiller Flow</strong></p>

<p>Helm v2 is made of two components:</p>

<ul>
  <li>A server called Tiller, which runs inside your Kubernetes cluster.</li>
  <li>A client called Helm, which runs on your local machine.</li>
</ul>

<p>Helm version 2 uses a Tiller pod to deploy in the cluster. This has led to a lot of issues with security and cluster permissions. The new Helm v3 does not deploy a pod.</p>

<p>With the Helm client you can browse package repositories (containing published Charts), and deploy those Charts on your Kubernetes cluster. The Helm will download the chart and pass a request to Tiller to create a release, otherwise known as an instance of a chart. The release will be made of various resources running in the Kubernetes cluster.</p>

<h3 id="helm-v3">Helm v3</h3>

<p>With the near complete overhaul of Helm, the processes and commands have changed quite a bit. Expect to spend some time updating and integrating these changes if you are currently using Helm v2.</p>

<p>One of the most noticeable changes is the removal of the Tiller pod. This was an ongoing security issue, as the pod needed elevated permissions to deploy charts. The functionality is in the command alone, and no longer requires initialization to use.</p>

<p>In version 2, an update to a chart and deployment used a 2-way strategic merge for patching. This compared the previous manifest to the intended manifest, but not the possible edits done outside of <strong>helm</strong> commands. The third way now checked is the live state of objects.</p>

<p>Among other changes, software installation no longer generates a name automatically. One must be provided, or the <strong>–generated-name</strong> option must be passed.</p>

<h3 id="chart-contents">Chart Contents</h3>

<p>A <strong>chart</strong> is an archived set of Kubernetes resource manifests that make up a distributed application. You can learn more from the <a href="https://helm.sh/docs/topics/charts/">Helm 3 documentation</a>. Others exist and can be easily created, for example by a vendor providing software. Charts are similar to the use of independent YUM repositories.</p>

<p><strong>├── Chart.yaml
├── README.md
├── templates
│  ├── NOTES.txt
│  ├── _helpers.tpl
│  ├── configmap.yaml
│  ├── deployment.yaml
│  ├── pvc.yaml
│  ├── secrets.yaml
│  └── svc.yaml
└── values.yaml</strong></p>

<ul>
  <li>Chart.yaml</li>
</ul>

<p>The <strong>Chart.yaml</strong> file contains some metadata about the Chart, like its name, version, keywords, and so on, in this case, for MariaDB.</p>

<ul>
  <li>values.yaml</li>
</ul>

<p>The <strong>values.yaml</strong> file contains keys and values that are used to generate the release in your cluster. These values are replaced in the resource manifests using the Go templating syntax.</p>

<ul>
  <li>templates</li>
</ul>

<p>The <strong>templates</strong> directory contains the resource manifests that make up this MariaDB application.</p>

<h3 id="templates">Templates</h3>

<p>The templates are resource manifests that use the Go templating syntax. Variables defined in the <strong>values</strong> file, for example, get injected in the template when a release is created. In the MariaDB example we provided, the database passwords are stored in a Kubernetes secret, and the database configuration is stored in a Kubernetes ConfigMap.</p>

<p>We can see that a set of labels are defined in the Secret metadata using the Chart name, Release name, etc. The actual values of the passwords are read from the <strong>values.yaml</strong> file.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> 
    <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> 
        <span class="na">chart</span><span class="pi">:</span> <span class="s2">"</span><span class="s">-"</span>
        <span class="na">release</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
        <span class="na">heritage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">Opaque</span>
<span class="na">data</span><span class="pi">:</span>
    <span class="na">mariadb-root-password</span><span class="pi">:</span> 
    <span class="na">mariadb-password</span><span class="pi">:</span> 
</code></pre></div></div>

<h2 id="initializing-helm-v2">Initializing Helm v2</h2>

<p>Helm v3 does not need to be initialized.</p>

<p>As always, you can build Helm from source, or download a tarball. We expect to see Linux packages for the stable release soon. The current RBAC security requirements to deploy helm require the creation of a new <strong>serviceaccount</strong> and assigning of permissions and roles. There are several optional settings which can be passed to the <strong>helm init</strong> command, typically for particular security concerns, storage options and also a dry-run option.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>helm init
...
Tiller <span class="o">(</span>the helm server side component<span class="o">)</span> has been installed into your Kubernetes Cluster.
Happy Helming!

<span class="nv">$ </span>kubectl get deployments <span class="nt">--namespace</span><span class="o">=</span>kube-system
NAMESPACE    NAME           READY  UP-TO-DATE  AVAILABLE  AGE
kube-system  tiller-deploy  1/1    1           1          15s
</code></pre></div></div>

<p>The helm v2 initialization should have created a new <strong>tiller-deploy</strong> pod in your cluster. Please note that this will create a deployment in the <strong>kube-system</strong> namespace.</p>

<p>The client will be able to communicate with the tiller pod using port forwarding. Hence, you will not see any service exposing tiller.</p>

<h3 id="chart-repositories">Chart Repositories</h3>

<p>A default repository is included when initializing helm, but it’s common to add other repositories. Repositories are currently simple HTTP servers that contain an index file and a tarball of all the Charts present.</p>

<p>You can interact with a repository using the <strong>helm repo</strong> commands.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>helm repo add testing http://storage.googleapis.com/kubernetes-charts-testing

<span class="nv">$ </span>helm repo list
NAME URL
stable http://storage.googleapis.com/kubernetes-charts
<span class="nb">local </span>http://localhost:8879/charts
testing http://storage.googleapis.com/kubernetes-charts...
</code></pre></div></div>

<p>Once you have a repository available, you can search for Charts based on keywords. Below, we search for a <strong>redis</strong> Chart:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>helm search redis
WARNING: Deprecated index file format. Try <span class="s1">'helm repo update'</span>
NAME                     VERSION DESCRIPTION
testing/redis-cluster    0.0.5   Highly available Redis cluster with multiple se...
testing/redis-standalone 0.0.1   Standalone Redis Master testing/...
</code></pre></div></div>

<p>Once you find the chart within a repository, you can deploy it on your cluster.</p>

<h3 id="deploying-a-chart">Deploying a Chart</h3>

<p>To deploy a Chart, you can just use the <strong>helm install</strong> command. There may be several required resources for the installation to be successful, such as available PVs to match chart PVC. Currently, the only way to discover which resources need to exist is by reading the <strong>READMEs</strong> for each chart :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>helm install testing/redis-standalone
Fetched testing/redis-standalone to redis-standalone-0.0.1.tgz
amber-eel
Last Deployed: Fri Oct 21 12:24:01 2016
Namespace: default
Status: DEPLOYED

Resources:
<span class="o">==&gt;</span> v1/ReplicationController
NAME             DESIRED CURRENT READY AGE
redis-standalone 1       1       0     1s

<span class="o">==&gt;</span> v1/Service
NAME  CLUSTER-IP EXTERNAL-IP PORT<span class="o">(</span>S<span class="o">)</span>  AGE
redis 10.0.81.67 &lt;none&gt;      6379/TCP 0s

</code></pre></div></div>

<p>You will be able to list the release, delete it, even upgrade it and roll back.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>helm list
NAME      REVISION UPDATED                  STATUS   CHART
amber-eel 1        Fri Oct 21 12:24:01 2016 DEPLOYED redis-standalone-0.0.1
</code></pre></div></div>

<p>A unique, colorful name will be created for each helm instance deployed. You can also use kubectl to view new resources Helm created in your cluster.</p>

<p>The output of the deployment should be carefully reviewed. It often includes information on access to the applications within. If your cluster did not have a required cluster resource, the output is often the first place to begin troubleshooting.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
