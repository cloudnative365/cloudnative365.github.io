<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>thanos概念 | cloudnative365.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="thanos概念" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/keynotes_L4_architect_2_monitoring_12_thanos_conception.html" />
<meta property="og:url" content="http://localhost:4000/keynotes_L4_architect_2_monitoring_12_thanos_conception.html" />
<meta property="og:site_name" content="cloudnative365.github.io" />
<script type="application/ld+json">
{"headline":"thanos概念","url":"http://localhost:4000/keynotes_L4_architect_2_monitoring_12_thanos_conception.html","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=481468f1311b237dbb8ec4fec8c1099b04cbcc76">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">cloudnative365.github.io</a></h1>
      

      <h2 id="1-架构">1. 架构</h2>

<p>我们先来看看官方架构图</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/12_thanos_conception/arch.jpg" alt="arch.jpg" /></p>

<ul>
  <li>黄色的部分是prometheus，exporters和alertmanager的三大组件，是prometheus最原始的架构</li>
  <li>蓝色的部分中：Thanos Sidecar和Thanos Query就是我们上节课搭建的那两个组件</li>
  <li>深灰色的是存储部分，其中，Thanos ruler和Thanos Sidecar使用的是本地硬盘（其实也可以存储到对象存储上，但是没什么必要），而Thanos Storage Gateway和Thanos Compact可以去对象存储中获取数据。</li>
  <li>Thanos Storage Gateway：我们在上一节课程中看到了，启动时候的参数<code class="highlighter-rouge">--store 127.0.0.1:19190</code>，这个是sidecar暴露出来的gRPG的API接口，不是Storage Gateway，如果想要使用别的存储，需要使用<code class="highlighter-rouge">thanos store </code>命令，并且指定配置文件的位置，使用<code class="highlighter-rouge">--objstore.config-file</code>，我们后面讲集成存储的时候再说。</li>
  <li>Thanos Compact：他的作用是优化查询历史数据时候的查询速度。</li>
  <li>Ruler：和Prometheus的ruler差不多，也是通过调用alertmanager来发送报警的</li>
</ul>

<h2 id="2-安装和配置所有的组件">2. 安装和配置所有的组件</h2>

<h3 id="21-准备对象存储">2.1. 准备对象存储</h3>

<p>在我们正式安装所有的组件之前，我们还需要安装另外一个组件，这个组件thanos并不提供，他需要借助其他解决方案。<a href="https://thanos.io/tip/thanos/storage.md/">官方</a>给出的方案有下面几种</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/12_thanos_conception/image-20200911172122008.png" alt="image-20200911172122008" /></p>

<p>我们可以看到目前稳定版本的依然是公有云三大巨头，而中国在这方面也不甘落后，阿里和腾讯都有支持，但是都是Beta版本。为了效果更好，我们使用另外一个开源方案，MinIO。这是一个开源的项目，他可以兼容S3协议，连接方式也和S3一样的。我们后面讲分布式存储的时候会说他，其他任何的软件，只要是支持持久存储到s3，我们都可以使用MinIO来替代。我们的体系中还有另外一个项目要使用到MinIO，那就是Spinnaker。</p>

<p>这里我们使用非常简单的方式启动一个S3</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-p</span> 9000:9000 <span class="nt">--name</span> minio <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"MINIO_ACCESS_KEY=AKIAIOSFODNN7EXAMPLE"</span> <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"MINIO_SECRET_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"</span> <span class="se">\</span>
  <span class="nt">-v</span> /mnt/data:/data <span class="se">\</span>
  <span class="nt">-v</span> /mnt/config:/root/.minio <span class="se">\</span>
  minio/minio server /data
</code></pre></div></div>

<p>起来之后就可以看到图形界面了，而在启动时候的两个key和AWS上的两个KEY作用一样，后面配置文件需要用到。</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/12_thanos_conception/image-20200913225005302.png" alt="image-20200913225005302" /></p>

<p>我们创建一个bucket，叫thanos</p>

<h4 id="22--sidecar">2.2.  Sidecar</h4>

<p>在容器时代非常常见的一种扩展容器的方式，如果把thanos部署在容器当中，那么sidecar组件就要部署为sidecar形式。sidecar的作用有两个</p>

<ul>
  <li>把prometheus的数据备份到对象存储中</li>
  <li>为Thanos的其他组件提供一个可以访问prometheus的接口，这个接口是使用gRPC API的</li>
</ul>

<p>注意：如果想让Sidecar可以重新加载Prometheus节点，记得要在prometheus启动的时候加上<code class="highlighter-rouge">--web.enable-lifecycle</code>选项</p>

<h4 id="221-启动参数">2.2.1. 启动参数</h4>

<p>如果使用命令直接启动的话使用下面的配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos sidecar <span class="se">\</span>
    <span class="nt">--tsdb</span>.path            /var/prometheus <span class="se">\ </span>         <span class="c"># 需要指定prometheus的数据文件地址</span>
    <span class="nt">--prometheus</span>.url       <span class="s2">"http://localhost:9091"</span> <span class="se">\ </span> <span class="c"># 暴露查询API的地址</span>
    <span class="nt">--objstore</span>.config-file bucket_config.yaml <span class="se">\ </span>      <span class="c"># 对象存储的信息</span>
</code></pre></div></div>

<p>部署这个对于prometheus来说，基本不会有任何的影响。同时，他还可以起到备份的作用，如果我们不想备份，就不需要<code class="highlighter-rouge">--objstore.config-file</code>选项了。</p>

<h4 id="222-store-api">2.2.2. Store API</h4>

<p>Sidecar组件还包含了一个Store API，他暴露为gRPG形式的，可以让我们查询到存储在Prometheus中的metrics数据。在刚才的基础上，我们的sidecar参数就会扩展为</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos sidecar <span class="se">\</span>
    <span class="nt">--tsdb</span>.path                 /var/prometheus <span class="se">\</span>
    <span class="nt">--objstore</span>.config-file      bucket_config.yaml <span class="se">\</span>
    <span class="nt">--prometheus</span>.url            http://localhost:9090 <span class="se">\</span>
    <span class="nt">--http-address</span>              0.0.0.0:19191 <span class="se">\ </span><span class="c"># 这个是用来查询sidecar中的数据的</span>
    <span class="nt">--grpc-address</span>              0.0.0.0:19090   <span class="c"># 这个是用来查询prometheus中的数据的</span>
</code></pre></div></div>

<h4 id="223-上传以前的metrics">2.2.3. 上传以前的metrics</h4>

<p>如果需要上传以前的数据，我们需要使用<code class="highlighter-rouge">--shipper.upload-compacted</code>选项，他会把所有的prometheus的数据都上传（从prometheus启动之后的，存储在本地硬盘上的数据都上传）。而且删除的时候需要手动删除，除非我们需要验证从前的数据，否则一定要慎重打开这个选项。</p>

<h4 id="224-external-labels">2.2.4. External Labels</h4>

<p>prometheus中允许配置<code class="highlighter-rouge">external labels</code>。这样就可以定义它在全局中的角色了。由于Thanos的目的是为了整合不同实例中的数据，所以定义external label就变得至关重要。</p>

<p>比如，在我们的prometheus中就可以这样定义</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">global</span><span class="pi">:</span>
  <span class="na">external_labels</span><span class="pi">:</span>
    <span class="na">region</span><span class="pi">:</span> <span class="s">eu-west</span>
    <span class="na">monitor</span><span class="pi">:</span> <span class="s">infrastructure</span>
    <span class="na">replica</span><span class="pi">:</span> <span class="s">A</span>
</code></pre></div></div>

<h3 id="23-querierquery">2.3. Querier/Query</h3>

<h4 id="231-启动选项">2.3.1. 启动选项</h4>

<p>我们为一个或者多个Prometheus实例配置的Sidecar之后，我们就可以使用query组件来通过PromQL查询来同时查询所有的metrics。</p>

<p>这个组件是无状态的，可以水平扩展的，他可以部署任意的副本，一旦连接上Sidecar之后，他会自动的检测哪个Prometheus服务器需要被连接来做查询。</p>

<p>Query同样使用Prometheus官方的HTTP接口，因此他同样支持外部工具，比如Grafana。他还同时提供了一个类似于Prometheus的界面来查询和存储状态。</p>

<p>我们可以这样启动一个Query</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos query <span class="se">\</span>
    <span class="nt">--http-address</span> 0.0.0.0:19192 <span class="se">\ </span><span class="c"># 图形界面的地址</span>
    <span class="nt">--store</span>        1.2.3.4:19090 <span class="se">\ </span><span class="c"># 静态gRPC地址，用于查询</span>
    <span class="nt">--store</span>        1.2.3.5:19090 <span class="se">\ </span><span class="c"># 还可以设置多个</span>
    <span class="nt">--store</span>        dnssrv+_grpc._tcp.thanos-store.monitoring.svc <span class="c">#还支持dns的方式暴露</span>
</code></pre></div></div>

<h4 id="232-对prometheus集群架构中的数据进行去重">2.3.2. 对Prometheus集群架构中的数据进行去重</h4>

<p>刚才在sidecar中说到了external_label，这里对于集群的角色分类，就是靠的这个标签。我们刚才配置了一个标签</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">global</span><span class="pi">:</span>
  <span class="na">external_labels</span><span class="pi">:</span>
    <span class="na">region</span><span class="pi">:</span> <span class="s">eu-west</span>
    <span class="na">monitor</span><span class="pi">:</span> <span class="s">infrastructure</span>
    <span class="na">replica</span><span class="pi">:</span> <span class="s">A</span>
</code></pre></div></div>

<p>这里我们就针对replica来去重，使用<code class="highlighter-rouge">--query.replica-label</code>参数</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos query <span class="se">\</span>
    <span class="nt">--http-address</span>        0.0.0.0:19192 <span class="se">\</span>
    <span class="nt">--store</span>               1.2.3.4:19090 <span class="se">\</span>
    <span class="nt">--store</span>               1.2.3.5:19090 <span class="se">\</span>
    <span class="nt">--query</span>.replica-label replica
    <span class="nt">--query</span>.replica-label replicaX 
</code></pre></div></div>

<h4 id="233-不同组件的通信">2.3.3. 不同组件的通信</h4>

<p>不同节点间通信的唯一渠道就是我们的gRPC storeAPI。我们通常会这样配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos query <span class="se">\</span>
    <span class="nt">--http-address</span> 0.0.0.0:19192 <span class="se">\</span>
    <span class="nt">--grpc-address</span> 0.0.0.0:19092 <span class="se">\</span>
    <span class="nt">--store</span>        1.2.3.4:19090 <span class="se">\</span>
    <span class="nt">--store</span>        1.2.3.5:19090 <span class="se">\</span>
    <span class="nt">--store</span>        dns+rest.thanos.peers:19092
</code></pre></div></div>

<h3 id="24-store-gateway">2.4. Store Gateway</h3>

<p>这个组件是用来为prometheus提供持久存储的，他同样需要暴露一个http地址和grpc地址来允许thanos集群来访问</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos store <span class="se">\</span>
    <span class="nt">--data-dir</span>             /var/thanos/store <span class="se">\</span>
    <span class="nt">--objstore</span>.config-file bucket_config.yaml <span class="se">\</span>
    <span class="nt">--http-address</span>         0.0.0.0:19191 <span class="se">\</span>
    <span class="nt">--grpc-address</span>         0.0.0.0:19090   
</code></pre></div></div>

<h3 id="25-compactor">2.5. Compactor</h3>

<p>这个组件是用来加速历史数据查询的，sidecar和Store Gate都会把一些历史数据写入对象存储当中，但是这些对象存储中的数据都算是历史数据，为了加速对他们的查询，就需要compactor组件了，他会优化对象存储中的数据，来加速查询</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thanos compact <span class="se">\</span>
    <span class="nt">--data-dir</span>             /var/thanos/compact <span class="se">\</span>
    <span class="nt">--objstore</span>.config-file bucket_config.yaml <span class="se">\</span>
    <span class="nt">--http-address</span>         0.0.0.0:19191
</code></pre></div></div>

<h3 id="26-ruler">2.6. ruler</h3>

<p>和prometheus的ruler类似，我们后面讲报警再说</p>

<h3 id="27-对象存储">2.7. 对象存储</h3>

<p>一个正常的s3存储的配置如下</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">type</span><span class="pi">:</span> <span class="s">S3</span>
<span class="na">config</span><span class="pi">:</span>
  <span class="na">bucket</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">endpoint</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">region</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">access_key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">insecure</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">signature_version2</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">secret_key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">put_user_metadata</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">http_config</span><span class="pi">:</span>
    <span class="na">idle_conn_timeout</span><span class="pi">:</span> <span class="s">1m30s</span>
    <span class="na">response_header_timeout</span><span class="pi">:</span> <span class="s">2m</span>
    <span class="na">insecure_skip_verify</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">trace</span><span class="pi">:</span>
    <span class="na">enable</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">part_size</span><span class="pi">:</span> <span class="s">134217728</span>
  <span class="na">sse_config</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">kms_key_id</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">kms_encryption_context</span><span class="pi">:</span> <span class="pi">{}</span>
    <span class="na">encryption_key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
</code></pre></div></div>

<p>最少也需要提供这四个选项<code class="highlighter-rouge">bucket</code>, <code class="highlighter-rouge">endpoint</code>, <code class="highlighter-rouge">access_key</code>, 和 <code class="highlighter-rouge">secret_key</code>。也就是minIO的四个选项，bucket_config.yaml文件内容如下</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span>: S3
config:
  bucket: <span class="s2">""</span>
  endpoint: <span class="s2">"localhost:9000"</span>
  access_key: <span class="s2">"AKIAIOSFODNN7EXAMPLE"</span>
  insecure: <span class="nb">false
  </span>signature_version2: <span class="nb">false
  </span>secret_key: <span class="s2">"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"</span>
</code></pre></div></div>



      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
