<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>云原生的身世之谜 | cloudnative365.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="云原生的身世之谜" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 什么是云原生" />
<meta property="og:description" content="1 什么是云原生" />
<link rel="canonical" href="http://localhost:4000/cloudnative.html" />
<meta property="og:url" content="http://localhost:4000/cloudnative.html" />
<meta property="og:site_name" content="cloudnative365.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-23T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"云原生的身世之谜","url":"http://localhost:4000/cloudnative.html","dateModified":"2020-03-23T00:00:00+08:00","datePublished":"2020-03-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/cloudnative.html"},"description":"1 什么是云原生","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=481468f1311b237dbb8ec4fec8c1099b04cbcc76">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">cloudnative365.github.io</a></h1>
      

      <h2 id="1-什么是云原生">1 什么是云原生</h2>

<p>Cloud Native翻译为云原生，是由Pivotal的攻城狮Matt Stine提出的一个概念，它是一个思想的集合，包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。Cloud Native既包含技术（微服务，敏捷基础设施），也包含管理（DevOps，持续交付，康威定律，重组等）。Cloud Native也可以说是一系列Cloud技术、企业管理方法的集合。</p>

<p><img src="/../_posts/pics/cloudnative/222c485b6dcc44762d65201584886558.png" alt="file" /></p>

<h2 id="2-云原生技术发展的历史">2. 云原生技术发展的历史</h2>

<p><img src="/../_posts/pics/cloudnative/222e0dfcf7f9f4c7794f201584886745.png" alt="file" /></p>

<ul>
  <li>2004 年— 2007 年，Google 已在内部大规模地使用像 Cgroups 这样的容器技术；</li>
  <li>2008 年，Google 将 Cgroups 合并进入了 Linux 内核主干；</li>
  <li>2013 年，Docker 项目正式发布。</li>
  <li>2014 年，Kubernetes 项目也正式发布。这样的原因也非常容易理解，因为有了容器和 Docker 之后，就需要有一种方式去帮助大家方便、快速、优雅地管理这些容器，这就是 Kubernetes 项目的初衷。在 Google 发布了 Kubernetes 之后，这个项目的发展速度非常之快。</li>
  <li>2015 年，由Google、Redhat 以及微软等大型云计算厂商以及一些开源公司共同牵头成立了 CNCF 云原生基金会。CNCF 成立之初，就有 22 个创始会员，而且 Kubernetes 也成为了 CNCF 托管的第一个开源项目。在这之后，CNCF 的发展速度非常迅猛；</li>
  <li>2017 年，CNCF 达到 170 个成员和 14 个基金项目；</li>
  <li>2018 年，CNCF 成立三周年有了 195 个成员，19 个基金会项目和 11 个孵化项目，如此之快的发展速度在整个云计算领域都是非常罕见的。</li>
</ul>

<h2 id="3-云原生技术的现状">3. 云原生技术的现状</h2>

<p>CNCF 有一张云原生<a href="https://landscape.cncf.io/images/landscape.png">全景图</a>在这个全景图里已经有 200 多个项目和产品了，这些项目和产品也都是和 CNCF 的观点所契合的。 这个全景图是在的太大了，每次KubeCon大会的时候，上台演讲的人都会担心屏幕无法把全景图显示出来。这个全景图我在加载的时候用了1分多钟，大小是MB。上面密密麻麻的名字会让有密集恐惧症的人立马起一身的鸡皮疙瘩。为了照顾大家的网速，我这里给大家做一个缩小版的截图，但是有兴趣的朋友一定要看一看，上面有非常多的logo都是我们耳闻能详的软件。如果你想成为一个云原生架构师，那么上面的软件起码要知道是干什么用的，如果说自己是资深的架构师，起码要亲自部署过才敢这么称呼自己吧。</p>

<p><img src="/../_posts/pics/cloudnative/222ee31039bbf936b7e9901584889508.png" alt="file" /></p>

<p>所以如果以这张全景图作为背景，加以思考就会发现，我们今天所讨论的云原生其实主要谈论了以下几点：</p>

<ul>
  <li>云原生基金会 云原生基金会，英文缩写叫CNCF，全称是Cloud Native Computing Foundation，是目前云计算领域最成功的开源基金会之一，是kubenetes，containerd，prometheus等著名开源项目的托管基金会。</li>
  <li>云原生技术社区 CNCF目前托管的30多个正式项目共同构成了现代云计算生态的基石，其中kubernetes项目是全世界第四活跃的开源项目。</li>
  <li>云原生技术产业 全球各大公有云厂商和100多个技术创业公司持续的投入，总体市场与2021年逼近1000亿美元。国内的互联网企业纷纷全面投入云计算行业。</li>
</ul>

<h2 id="4-回顾2019年">4. 回顾2019年</h2>

<p>2019 年正是云原生时代的关键节点，为什么这么说？我们这里就为大家简单梳理一下。</p>

<p>从 2013 年 Docker 项目发布开始说起，Docker 项目的发布使得全操作系统语义的沙盒技术唾手可得，使得用户能够更好地、更完整地打包自己的应用，使得开发者可以轻而易举的获得了一个应用的最小可运行单位，而不需要依赖任何 PaaS 能力。这对经典 PaaS 产业其实是一个“降维打击”。</p>

<p>2014 年的时候，Kubernetes 项目发布，其意义在于 Google 将内部的 Borg/Omega 系统思想借助开源社区实现了“重生”，并且提出了“容器设计模式”的思想。而 Google 之所以选择间接开源 Kubernetes 而不是直接开源 Borg 项目，其实背后的原因也比较容易理解：Borg/Omega 这样的系统太复杂了，是没办法提供给 Google 之外的人使用，但是 Borg/Omega 这样的设计思想却可以借助 Kubernetes 让大家接触到，这也是开源 Kubernetes 的重要背景。</p>

<p>这样到了 2015 年到 2016 年，就到了容器编排“三国争霸”的时代，当时 Docker、Swarm、Mesos、Kubernetes 都在容器编排领域展开角逐，他们竞争的原因其实也比较容易理解， 那就是 Docker 或者容器本身的价值虽然大，但是如果想要让其产生商业价值或者说对云的价值，那么就一定需要在编排上面占据一个有利的位置。</p>

<p>Swarm 和 Mesos 的特点，那就是各自只在生态和技术方面比较强，其中，Swarm 更偏向于生态，而 Mesos 技术更强一些。相比之下， Kubernetes 则兼具了两者优势，最终在 2017 年“三国争霸”的局面中得以胜出，成为了当时直到现在的容器编排标准。这一过程的代表性事件就是 Docker 公司宣布在核心产品中内置了 Kubernetes 服务，并且 Swarm 项目逐渐停止维护。</p>

<p>到了 2018 年的时候，云原生技术理念开始逐渐萌芽，这是因为此时 Kubernetes 以及容器都成为了云厂商的既定标准，以“云”为核心的软件研发思想逐步形成。</p>

<p>而到了 2019 年，云原生技术普及元年。首先大家可以看到，在 2019 年，阿里巴巴宣布要全面上云，而且“上云就要上云原生”。我们还可以看到，以“云”为核心的软件研发思想，正逐步成为所有开发者的默认选项。像 Kubernetes 等云原生技术正在成为技术人员的必修课，大量的工作岗位正在涌现出来。这种背景下，“会 Kubernetes”已经远远不够了，“懂 Kubernetes”、“会云原生架构”的重要性正日益凸显出来。 从 2019 年开始，云原生技术将会大规模普及，这也是为什么大家都要在这个时间点上学习和投资云原生技术的重要原因。</p>

<h2 id="5-云原生的技术范畴landscape">5. 云原生的技术范畴（Landscape）</h2>

<p><img src="/../_posts/pics/cloudnative/222ba706de12fbca470ab01584889205.png" alt="file" /></p>

<ol>
  <li>容器化。目前最流行的容器化技术是Docker，你可以将任意大小的应用程序和依赖项，甚至在模拟器上运行的一些程序，都进行容器化。随着时间的推移，你还可以对应用程序进行分割，并将未来的功能编写为微服务。</li>
  <li>CI/CD（持续集成和持续发布）。创建CI/CD环境，从而使源代码上的任意修改，都能够自动通过容器进行编译、测试，并被部署到预生产甚至生产环境中。</li>
  <li>应用编排。Kubernetes是目前市场上应用编排领域被最广泛应用的工具，Helm Charts可以用来帮助应用开发和发布者用于升级Kubernetes上运行的应用。</li>
  <li>监控和分析。在这一步中，用户需要为平台选择监控、日志以及跟踪的相关工具，例如将Prometheus用于监控、Fluentd用于日志、Jaeger用于整个应用调用链的跟踪。</li>
  <li>服务代理、发现和治理。CoreDNS、Envoy和LInkerd可以分别用于服务发现和服务治理，提供服务的健康检查、请求路由、和负载均衡等功能。</li>
  <li>网络。Calico、Flannel以及Weave Net等软件用于提供更灵活的网络功能。</li>
  <li>分布式数据库和存储。分布式数据库可以提供更好的弹性和伸缩性能，但同时需要专业的容器存储予以支持。</li>
  <li>流和消息处理。当应用需要比JSON-REST这个模式更高的性能时，可以考虑使用gRPC或者NATS。gRPC是一个通用的RPC（远程调用）框架（类似各种框架中的RPC调用），NATS是一个发布/订阅和负载均衡的消息队列系统。</li>
  <li>容器镜像库和运行环境。Harbor是目前最受欢迎的容器镜像库，同时，你也可以选择使用不同的容器运行环境用于运行容器程序。</li>
  <li>软件发布。最后可以借助Notary等软件用于软件的安全发布。</li>
</ol>

<h2 id="6-云原生思想的两个理论">6. 云原生思想的两个理论</h2>

<ul>
  <li>第一个理论基础是：不可变基础设施。这一点目前是通过容器镜像来实现的，其含义就是应用的基础设施应该是不可变的，是一个自包含、自描述可以完全在不同环境中迁移的东西；</li>
  <li>第二个理论基础就是：云应用编排理论。当前的实现方式就是 Google 所提出来的“容器设计模式”，这也是本系列课程中的 Kubernetes 部分所需主要讲解的内容。</li>
</ul>

<h2 id="7-基础设施向云演进的过程">7. 基础设施向云演进的过程</h2>

<p>首先为大家介绍一下“不可变基础设施”的概念。其实，应用所依赖的基础设施也在经历一个向云演进的过程，举例而言，对于传统的应用基础设施而言，其实往往是可变的。</p>

<p>大家可能经常会干这样一件事情，比如需要发布或者更新一个软件，那么流程大致是这样的，先通过 SSH 连到服务器，然后手动升级或者降级软件包，逐个调整服务器上的配置文件，并且将新代码直接都部署到现有服务器上。因此，这套基础设施会不断地被调整和修改。</p>

<p>但是在云上，对“云”友好的应用基础设施是不可变的。</p>

<p>这种场景下的上述更新过程会这么做：一旦应用部署完成之后，那么这套应用基础设施就不会再修改了。如果需要更新，那么需要现更改公共镜像来构建新服务直接替换旧服务。而我们之所以能够实现直接替换，就是因为容器提供了自包含的环境（包含应用运行所需的所有依赖）。所以对于应用而言，完全不需要关心容器发生了什么变化，只需要把容器镜像本身修改掉就可以了。因此，对于云友好的基础设施是随时可以替换和更换的，这就是因为容器具有敏捷和一致性的能力，也就是云时代的应用基础设施。</p>

<p>所以，总结而言，云时代的基础设施就像是可以替代的“牲口”，可以随时替换；而传统的基础设施则是独一无二的“宠物”，需要细心呵护，这就体现出了云时代不可变基础设施的优点。</p>

<h2 id="8-基础设施向云演进的意义">8. 基础设施向云演进的意义</h2>

<p>所以，像这样的基础设施向“不可变”演进的过程，为我们提供了两个非常重要的优点。</p>

<p>1、基础设施的一致性和可靠性。同样一个镜像，无论是在美国打开，在中国打开，还是在印度打开都是一样的。并且其中的 OS 环境对于应用而言都是一致的。而对于应用而言，它就不需要关心容器跑在哪里，这就是基础设施一致性非常重要的一个特征。</p>

<p>2、这样的镜像本身就是自包含的，其包含了应用运行所需要的所有依赖，因此也可以漂移到云上的任何一个位置。</p>

<p>此外，云原生的基础设施还提供了简单、可预测的部署和运维能力。由于现在有了镜像，应用还是自描述的，通过镜像运行起来的整个容器其实可以像 Kubernetes 的 Operator 技术一样将其做成自运维的，所以整个应用本身都是自包含的行为，使得其能够迁移到云上任何一个位置。这也使得整个流程的自动化变得非常容易。</p>

<p>应用本身也可以更好地扩容，从 1 个实例变成 100 个实例，进而变成 1 万个实例，这个过程对于容器化后的应用没有任何特殊的。最后，我们这时也能够通过不可变的基础设施来地快速周围的管控系统和支撑组件。因为，这些组件本身也是容器化的，是符合不可变基础设施这样一套理论的组件。</p>

<p>以上就是不可变基础设施为用户带来的最大的优点。</p>

<h2 id="9-云原生关键技术点">9. 云原生关键技术点</h2>

<p>当我们回过头来看云原生关键技术点或者说它所依赖的技术理论的时候，可以看到主要有这样的四个方向：</p>

<ol>
  <li>如何构建自包含、可定制的应用镜像；</li>
  <li>能不能实现应用快速部署与隔离能力；</li>
  <li>应用基础设施创建和销毁的自动化管理；</li>
  <li>可复制的管控系统和支撑组件。</li>
</ol>

<h2 id="总结">总结</h2>

<p>“未来的软件一定是生长于云上的”这是云原生理念的最核心假设。而所谓“云原生”，实际上就是在定义一条能够让应用最大程度利用云的能力、发挥云的价值的最佳路径。在这条路径上，脱离了“应用”这个载体，“云原生”就无从谈起；容器技术，则是将这个理念落地、将软件交付的革命持续进行下去的重要手段之一。</p>



      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
