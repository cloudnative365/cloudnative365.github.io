<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>监控概述 | cloudnative365.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="监控概述" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/keynotes_L4_architect_2_monitoring_1_monitoring_overview.html" />
<meta property="og:url" content="http://localhost:4000/keynotes_L4_architect_2_monitoring_1_monitoring_overview.html" />
<meta property="og:site_name" content="cloudnative365.github.io" />
<script type="application/ld+json">
{"headline":"监控概述","url":"http://localhost:4000/keynotes_L4_architect_2_monitoring_1_monitoring_overview.html","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=481468f1311b237dbb8ec4fec8c1099b04cbcc76">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">cloudnative365.github.io</a></h1>
      

      <h2 id="1-监控系统">1. 监控系统</h2>

<h3 id="11-什么是监控系统">1.1. 什么是监控系统</h3>

<p>这让我想起了多年前面试的时候的囧事，面试官问我：“你知道什么监控系统？”。我那个时候刚考完RHCE，对于系统架构还处于懵懂状态，我面对这个问题的第一个反应就是这个。</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/273480.jpg" alt="img" /></p>

<p>这个算是监控的一部分，不过是机房级别的监控，和我们要讨论的监控从哲学角度是一个东西，但是从软件角度却大相径庭。</p>

<h3 id="12-术语定义">1.2. 术语定义</h3>

<p>在讨论监控系统时，目前几乎没有通用的术语。即使在Google内部，不同的团队也在使用不同的术语，以下是绝大部分通用的术语。</p>

<ul>
  <li>
    <p>监控（monitoring）</p>

    <p>收集、处理、汇总，并且显示关于某个系统的实时量化数据，例如请求的数量和类型，错误的数量和类型，以及处理用时，应用服务器的存活时间等。</p>
  </li>
  <li>
    <p>白盒监控（white-box monitoring）</p>

    <p>依靠系统内部暴露的一些性能指标进行监控。包括日志分析、Java虚拟机提供的监控接口，或者一个列出内部统计数据的HTTP接口进行监控。</p>
  </li>
  <li>
    <p>黑盒监控（black-box monitoring）</p>

    <p>通过测试某种外部用户可见的系统行为进行监控。</p>
  </li>
  <li>
    <p>监控台页面（dashboard）</p>

    <p>提供某个服务核心指标一览服务的应用程序（一般是基于Web的）。该应用程序可能会提供过滤功能（filter）、选择功能（selector）等，但是最主要的功能是用来显示系统最重要的指标。该程序同时可以显示相应团队的一些信息，包括目前工单的数量、高优先级的Bug列表、目前的on-call工程师和最近进行的生产发布等。</p>
  </li>
  <li>
    <p>警报（alert）</p>

    <p>目标对象是某个人发向某个系统地址的一个通知。目的地可以包括工单系统、E-mail地址，或者某个传呼机。相应的，这些警报被分类为：工单、E-mail警报，以及紧急警报。</p>
  </li>
  <li>
    <p>根源问题（root cause）</p>

    <p>指系统（软件或流程）中的某种缺陷。这个缺陷如果被修复，就可以保证这种问题不会再以同样的方式发生。某一个故障情况可能同时具有多个根源问题：例如，有可能自动化程度不够，软件在异常输入下崩溃，以及对生成配置文件的脚本测试不足等。这里每一个因素都是一个根源问题，并且每一个都需要被修复。</p>
  </li>
  <li>
    <p>节点或者机器（node/machine）</p>

    <p>这里的两个术语是可以互换的：指在物理机、虚拟机，或者容器内运行的某个实例。某个单独的物理机器上可能有多个服务需要监控，这些服务可能具有如下特点。</p>

    <ul>
      <li>相互关联的服务：例如Web服务器与对应的缓存服务器。</li>
      <li>不相关的服务，它们仅仅共享硬件：例如代码仓库和把文件存放在代码仓库中的配置管理系统的主进程。例如Puppet（https://puppetlabs.com/puppet/puppetopen-source）和Chef（https://www.chef.io/chef/）。</li>
    </ul>
  </li>
  <li>
    <p>推送（push）</p>

    <p>关于某个服务正在运行的软件或者其配置文件的任何改动。（好处在于实时性比较高，但是如果agent挂了需要长时间才会有反应）</p>
  </li>
  <li>
    <p>拉取（pull）（个人理解）</p>

    <p>和push相反，服务器会主动去agent上问这个节点有没有变动。（好处在于如果agent挂了，服务器的间隔时间只要够短，就可以快速响应）</p>
  </li>
</ul>

<h3 id="13-从运维到监控">1.3. 从运维到监控</h3>

<p>我们运维的最重要职责之一就是要保证我们的环境稳定，为了让我们知道环境稳定与否，我们就需要去确认。当然不是人工去确认，而是使用一些摄像头去24小时监控，在我们的监控系统中，我们叫他Agent。而Agent会吧他看到的东西主动或者被动的传递给监控服务器，服务器会有自己的逻辑去判断我们采集来的数据是否符合标准，符合标准的不做任何处理，不符合标准的就需要去报警，来通知运维人员去处理。</p>

<p>我们这里面涉及到的几个概念可以归纳如下</p>

<table>
  <thead>
    <tr>
      <th>图中显示的监控系统</th>
      <th>一般监控系统</th>
      <th>prometheus监控系统</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>摄像头</td>
      <td>agent</td>
      <td>exporter</td>
    </tr>
    <tr>
      <td>好多屏幕组成的监控平台</td>
      <td>server</td>
      <td>prometheus</td>
    </tr>
    <tr>
      <td>值班的人</td>
      <td>报警系统</td>
      <td>alertmanager</td>
    </tr>
    <tr>
      <td>打电话</td>
      <td>发送报警到手机</td>
      <td>发送报警到微信</td>
    </tr>
    <tr>
      <td>维修工人</td>
      <td>运维工程师</td>
      <td>运维工程师</td>
    </tr>
  </tbody>
</table>

<h3 id="14-数据采集方式">1.4. 数据采集方式</h3>

<p>一般来说，服务器获取数据的方式有两种，一种是推，一种是拉。推是由agent主动向server报告，而拉是由服务器去客户端取数据，而prometheus主要是拉数据。</p>

<p>从1.2的图中可以看出，prometheus的agent叫exporter，也就是打报告的人，这个打报告的人会把系统的状态通过特定端口暴露出来，也就是写成报告，让prometheus去采集，这是一种拉的方式。</p>

<h3 id="15-架构图">1.5. 架构图</h3>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/architecture.png" alt="Prometheus architecture" /></p>

<p>从图中我们可以看到我们刚才讲到的拉的方式，而prometheus还有一个组件叫Pushgateway，他是负责收集一次性的指标的，但是他的方式是推，也就是任务执行完成后，会把数据推送到Pushgateway上，再由Prometheus去拉。</p>

<p>在右上角还有一个组件叫AlertManager，他主要是来负责报警的，他支持把报警推送到多个平台，甚至是微信。</p>

<h3 id="16-软件清单">1.6. 软件清单</h3>

<p>因此，我们需要安装的程序如下</p>

<ul>
  <li>exporters：有很多的exporter，或者我们可以开发自己的exporter</li>
  <li>Prometheus Server：时序数据库，可以通过http方式来管理</li>
  <li>alertmanager：报警系统，但是报警规则要在Prometheus上定义</li>
  <li>pushgateway：接受一次性metrics推送，然后暴露出来</li>
  <li>grafana：成图工具，非常绚丽的界面</li>
</ul>

<h3 id="17-prometheus的优点缺点">1.7. Prometheus的优点（缺点）</h3>

<ul>
  <li>
    <p>契合google SRE的理念，与kubernetes集成效果卓越，是云原生系统中监控的不二选择</p>
  </li>
  <li>粒度小，可以精确到1~5的采集精度（消耗资源巨大，对硬件性能要求很高）</li>
  <li>插件丰富，各种eporter，甚至可以自定义（模板少，需要自己根据环境定义自己的指标）</li>
  <li>基于数学计算模型设计，有大量的函数，可以实现复杂的逻辑（对于新手不太友好，入门门槛高）</li>
  <li>基于http的存取方式让他非常容易和其他系统集成（有些功能需要和其他的软件一起才能实现）</li>
  <li>图形美观（需要和grafana集成）</li>
  <li>（数据不太适合持久化存储）</li>
</ul>

<h2 id="2-常用的监控数据库">2. 常用的监控数据库</h2>

<h3 id="21-监控数据的存储软件">2.1. 监控数据的存储软件</h3>

<p>说到监控数据的存储软禁，无非就是在说数据库。咱们现在常见的大部分数据库都是用来存储业务数据的关系型数据库，比如Oracle，MySQL等等。但是对于咱们promethe的监控指标的存储，我们不需要非常复杂的依赖关系，甚至不需要满足三范式。我们只需要根据等量的时间间隔，在某个时间点去采集一下数据就好了，针对这种场景，时序数据库就是最好的选择了。当然，还有很多的监控软件并没有选择时序数据库，他们选择自己创造了自己的数据库。</p>

<h3 id="22-常见的数据库产品">2.2. 常见的数据库产品</h3>

<p>数据库从不同的角度可以有多种分类，比如从满足范式的程度，我们可以分为SQL，NoSQL和NewSQL。而我们这里的分类如下：</p>

<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Subcategory</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Databases</td>
      <td>Time-series时序数据库</td>
      <td>Timescale，KDB，AWS Timestream，OpenTSDB，Prometheus，GridDB，Influxdb</td>
    </tr>
    <tr>
      <td> </td>
      <td>Industrial IoT data historian工业物联网数据库</td>
      <td>OSI-PI，WonderWare，Rockwell</td>
    </tr>
    <tr>
      <td> </td>
      <td>Relational关系型数据库</td>
      <td>Postgres，MySQL，MariaDB，Oracle，AWS RDS</td>
    </tr>
    <tr>
      <td> </td>
      <td>Document文档数据库</td>
      <td>MongoDB，AWS DynamoDB</td>
    </tr>
    <tr>
      <td> </td>
      <td>Memory内存数据库</td>
      <td>Redis</td>
    </tr>
    <tr>
      <td> </td>
      <td>Other其他</td>
      <td>Cassandra，Neo4j，AWS Elasticache</td>
    </tr>
    <tr>
      <td>Monitoring</td>
      <td>Open source infrastructure monitoring开源基础设施监控</td>
      <td>Prometheus，Nagios，Zabbix</td>
    </tr>
    <tr>
      <td> </td>
      <td>Closed-source infrastructure monitoring闭源基础设施监控</td>
      <td>Datadog，SignalFX，New Relic</td>
    </tr>
    <tr>
      <td> </td>
      <td>App Performance Management（APM）应用性能管理</td>
      <td>NewRelic，AppDynamics，Datadog，SignalFX</td>
    </tr>
    <tr>
      <td> </td>
      <td>Log Management日志管理</td>
      <td>Splunk，Elastic，Sumo Login，Datadog</td>
    </tr>
  </tbody>
</table>

<p>而在CNCF的landscape里面的可以看到更多的产品</p>

<ul>
  <li>应用数据库，https://landscape.cncf.io/category=database&amp;format=card-mode&amp;grouping=category</li>
</ul>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/Jietu20200714-220753.jpg" alt="Jietu20200714-220753" /></p>

<ul>
  <li>监控，https://landscape.cncf.io/category=observability-and-analysis&amp;format=card-mode&amp;grouping=category</li>
</ul>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/Jietu20200714-220959.jpg" alt="Jietu20200714-220959" /></p>

<p>这么多软件一个屏幕已经放不开了，我是缩小之后才放在文章中的。图中用蓝框画出来的软件是注册在CNCF下面的软件。粗略的看一下就会发现不管是什么软件都在和云计算挂钩，即使oracle或者DB2这种老牌的数据库在这个时代也会推出一些云功能，或者向云原生靠拢。</p>

<h3 id="23-时序数据库">2.3. 时序数据库</h3>

<p>2017年时序数据库忽然火了起来。</p>

<ul>
  <li>2017年2月，Facebook开源了beringei时序数据库</li>
  <li>2017年4月，基于PostgreSQL打造的时序数据库TimeScaleDB也开源了</li>
  <li>2016年7月，百度云在其天工物联网平台上发布了国内首个多租户的分布式时序数据库产品TSDB</li>
  <li>opentsdb是基于Hbase的时序数据库，早在2011年就有了1.0版本，但是真正成熟是在2014年5月之后的2.0版本</li>
  <li>GridDB是在2013年release的，是由C++写成的</li>
  <li>
    <p>kdb+（基于q或者k语言的db, 增强版，也简称kdb）被官方称为世界上最快的时间序列数据库</p>
  </li>
  <li>Timestream是AWS上的一款SaaS产品，同样是针对物联网的时序数据库</li>
  <li>Influxdb是由Go语言开发的时序数据库，性能非常稳定，社区版免费试用，商业版支持集群，但是需要收费，我们这个专题会使用Influxdb作为prometheus数据持久化的解决方案，同时，我会教大家怎样使用合理运用架构来使用社区版建立集群。</li>
</ul>

<h2 id="3-为什么需要监控">3. 为什么需要监控</h2>

<h3 id="31-报警">3.1. 报警</h3>

<p>我们前面聊到了监控的作用，就是“插眼”（引用自英雄联盟）。让我们可以持续的观察想要观察的东西，而如果发现了异常的状态之后的动作才是我们需要监控的最终目的。</p>

<ul>
  <li>
    <p>通常情况下，如果监控到了异常的行为，我们会“报警”（alert），让相关人员知道，然后采取人工的动作。</p>
  </li>
  <li>
    <p>但是，我们前面学过了kubernetes，kubernetes的pod中有probe的机制，这个机制确实发现了异常之后直接采取action，而不去通知运维工程师。这种就是自动修复的动作。</p>
  </li>
</ul>

<p>而我们监控的终极目标就是要自动修复！早先，阿里巴巴每年双11活动的时候，会产生巨大的系统压力，阿里集团各个系统的人员都会集中到阿里巴巴集团的杭州总部待命，在园区各个地方搭起帐篷待命。</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/Jietu20200714-221031.jpg" alt="Jietu20200714-221031" /></p>

<p>而从2017年开始，自从阿里集团开始使用公有云作为基础设施来提供服务之后，就实现了“喝茶过双十一”。那么，可想而知，如果某一个环节出现了问题，比如资源不足，应用宕机，其实都是由定义好的规则自动修复的。而监控资源，监控应用的监控系统就是整个环节中的第一个重要步骤了，我们会在监控中定义好“底线”，也就是阈值，一旦系统触发了底线，我们的监控就会采取相应的措施，比如：等待3秒，如果不恢复，就告诉自动修复的程序去修复，如果再无法修复，就告诉运维工程师，如果运维工程师不响应，就给经理发消息。</p>

<h3 id="32-查看趋势">3.2. 查看趋势</h3>

<p>查看数据库目前的数据量，以及增长速度。又例如每日活跃用户的数量增长的速度。跨时间范围的比较，或者是观察实验组与控制组之间的区别</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130303337372f31363035396662332d316466342d383938312d656534622d3530656663326233356465352e706e67.png" alt="See the source image" /></p>

<p>当然Prometheus提供的图形界面基本沦为了运维工程师调试PromSQL的的工具，真正给老板看的图应该是这样的。</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/grafana-esxi-022.png" alt="See the source image" /></p>

<h3 id="33-构建监控台页面">3.3. 构建监控台页面</h3>

<p>我们上面展示了一些个指标，但是真正有用的指标，或者“黄金指标”一般是说</p>

<ul>
  <li>
    <p>延迟</p>

    <p>服务处理某个请求所需要的时间。这里区分成功请求和失败请求很重要。例如，某个由于数据库连接丢失或者其他后端问题造成的HTTP 500错误可能延迟很低。计算总体延迟时，如果将500回复的延迟也计算在内，可能会产生误导性的结果。但是，“慢”错误要比“快”错误更糟！因此，监控错误回复的延迟是很重要的。</p>
  </li>
  <li>
    <p>流量</p>

    <p>使用系统中的某个高层次的指标针对系统负载需求所进行的度量。对Web服务器来说，该指标通常是每秒HTTP请求数量，同时可能按请求类型分类（静态请求与动态请求）。针对音频流媒体系统来说，这个指标可能是网络I/O速率，或者并发会话数量。针对键值对存储系统来说，指标可能是每秒交易数量，或每秒的读取操作数量。</p>
  </li>
  <li>
    <p>错误</p>

    <p>请求失败的速率，要么是显式失败（例如HTTP 500），要么是隐式失败（例如HTTP 200 回复中包含了错误内容），或者是策略原因导致的失败（例如，如果要求回复在1s内发出，任何超过1s的请求就都是失败请求）。当协议内部的错误代码无法表达全部的失败情况时，可以利用其他信息，如内部协议，来跟踪一部分特定故障情况。监控方式也非常不一样：在负载均衡器上检测HTTP 500请求可能足够抓住所有的完全失败的请求，但是只有端到端的系统才能检测到返回错误内容这种故障类型。</p>
  </li>
  <li>
    <p>饱和度</p>

    <p>服务容量有多“满”。通常是系统中目前最为受限的某种资源的某个具体指标的度量。（在内存受限的系统中，即为内存；在I/O受限的系统中，即为I/O）。这里要注意，很多系统在达到100%利用率之前性能会严重下降，增加一个利用率目标也是很重要的。</p>

    <p>在复杂系统中，饱和度可以配合其他高层次的负载度量来使用：该服务是否可以正常处理两倍的流量，是否可以应对10%的额外流量，或者甚至应对当前更少的流量？对没有请求复杂度变化的简单服务来说（例如，“返回一个随机数”服务，或者是“返回一个全球唯一的单向递增整数”服务），根据负载测试中得到的一个固定数值可能就足够了。但是正如前文所述，大部分服务都需要使用某种间接指标，例如CPU利用率，或者网络带宽等来代替，因为这些指标通常有一个固定的已知的上限。延迟增加是饱和度的前导现象。99% 的请求延迟（在某一个小的时间范围内，例如一分钟）可以作为一个饱和度早期预警的指标。</p>
  </li>
  <li>
    <p>最后，饱和度同样也需要进行预测，例如“看起来数据库会在4个小时内填满硬盘”。</p>
  </li>
</ul>

<p>如果我们度量所有这4个黄金指标，同时在某个指标出现故障时发出警报（或者对于饱和度来说，快要发生故障时），能做到这些，服务的监控就基本差不多了。</p>

<h3 id="34-临时性的回溯分析">3.4. 临时性的回溯分析</h3>

<p>我们还有的时候需要查看很久之前的数据，但是这个功能其实Prometheus做的并不好，他默认会保留1个月的数据，想要查看更早的数据就需要借助于其他工具。因为Prometheus是时序数据库，也就是按照顺序存储数据，没有分区，热点数据或者压缩功能，这也是Prometheus的痛点之一。当然，我们后面会介绍怎样解决这个问题。</p>

<p><img src="/pages/keynotes/L4_architect/2_monitoring/pics/1_monitoring/GrafanaMonomicrolithsSlide4.png" alt="See the source image" /></p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
