<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" keynotes, basic, containerization, docker_network">
<title>Docker网络管理 | CloudNative knowledge</title>
<link rel="stylesheet" href="css/syntax.css">

<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/boxshadowproperties.css">
<!-- most color styles are extracted out to here -->
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Anchor.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="cloudnative365.gitpage.io" href="http://0.0.0.0:4000/feed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    <script>
        $(document).ready(function() {
            $("#tg-sb-link").click(function() {
                $("#tg-sb-sidebar").toggle();
                $("#tg-sb-content").toggleClass('col-md-9');
                $("#tg-sb-content").toggleClass('col-md-12');
                $("#tg-sb-icon").toggleClass('fa-toggle-on');
                $("#tg-sb-icon").toggleClass('fa-toggle-off');
            });
        });
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-static-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> 云原生技术课堂</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- toggle sidebar button -->
                <li><a id="tg-sb-link" href="#"><i id="tg-sb-icon" class="fa fa-toggle-on"></i> Nav</a></li>
                <!-- entries without drop-downs appear here -->




                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课程<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="lessons_syllabus.html">教学大纲</a></li>
                        
                        
                        
                        <li><a href="lessons_plans.html">开课计划</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课堂笔记<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="keynotes_L1_basic.html">基础课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L2_advanced.html">进阶课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L3_senior.html">高级课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L4_architect.html">架构师课程</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课堂风采<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="classes_teachers.html">讲师风采</a></li>
                        
                        
                        
                        <li><a href="classes_aboutus.html">关于我们</a></li>
                        
                        
                        
                        <li><a href="classes_successd.html">优秀学员作品</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">常用链接<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="https://www.cncf.io/" target="_blank" rel="noopener">CNCF Foundation</a></li>
                        
                        
                        
                        <li><a href="https://www.linuxfoundation.org/" target="_blank" rel="noopener">Linux Foundation</a></li>
                        
                        
                        
                        <li><a href="https://cd.foundation/" target="_blank" rel="noopener">CD Foundation</a></li>
                        
                        
                    </ul>
                </li>
                
                
                
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="Docker网络管理">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
  <div id="main">
    <!-- Content Row -->
    <div class="row">
        
        
            <!-- Sidebar Column -->
            <div class="col-md-3" id="tg-sb-sidebar">
                

<ul id="mysidebar" class="nav">
  <li class="sidebarTitle">进阶课程 </li>
  
  
  
      
  
  <li>
      <a title="课前准备" href="#">课前准备</a>
      <ul>
          
          
          
          <li><a title="Git的安装配置和使用" href="keynotes_L1_basic_git_blog.html">Git的安装配置和使用</a></li>
          
          
          
          
          
          
          <li><a title="MarkDown语言的使用" href="keynotes_L1_basic_markdown_blog.html">MarkDown语言的使用</a></li>
          
          
          
          
          
          
          <li><a title="使用GitPages搭建免费的个人博客" href="keynotes_L1_basic_gitpage_blog.html">使用GitPages搭建免费的个人博客</a></li>
          
          
          
          
          
          
          <li><a title="薅aws的羊毛" href="keynotes_L1_basic_aws_blog.html">薅aws的羊毛</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="第一章 容器化基础" href="#">第一章 容器化基础</a>
      <ul>
          
          
          
          <li><a title="第一节 容器化基础" href="mydoc_release_notes_60.html">第一节 容器化基础</a></li>
          
          
          
          
          
          
          <li><a title="第二节 使用Docker" href="mydoc_release_notes_60.html">第二节 使用Docker</a></li>
          
          
          
          
          
          
          <li><a title="第三节 Docker的网络" href="mydoc_release_notes_60.html">第三节 Docker的网络</a></li>
          
          
          
          
          
          
          <li><a title="第四节 Docker的存储卷" href="mydoc_release_notes_60.html">第四节 Docker的存储卷</a></li>
          
          
          
          
          
          
          <li><a title="第五节 Docker资源限制" href="mydoc_release_notes_60.html">第五节 Docker资源限制</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="第二章 容器化基础" href="#">第二章 容器化基础</a>
      <ul>
          
          
          
          <li><a title="第一节 Docker镜像" href="mydoc_release_notes_60.html">第一节 Docker镜像</a></li>
          
          
          
          
          
          
          <li><a title="第二节 私有镜像仓库" href="mydoc_release_notes_60.html">第二节 私有镜像仓库</a></li>
          
          
          
          
          
          
          <li><a title="第三节 Dockerfile" href="mydoc_release_notes_60.html">第三节 Dockerfile</a></li>
          
          
          
          
          
          
          <li><a title="第四节 harbor" href="mydoc_release_notes_60.html">第四节 harbor</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="第三章 容器运行时" href="#">第三章 容器运行时</a>
      <ul>
          
          
          
          <li><a title="第一节 containerd" href="mydoc_release_notes_60.html">第一节 containerd</a></li>
          
          
          
          
          
          
          <li><a title="第二节 cri-o" href="mydoc_release_notes_60.html">第二节 cri-o</a></li>
          
          
          
          
      </ul>
   </li>
     
      
      
      <!-- if you aren't using the accordion, uncomment this block:
         <p class="external">
             <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
         </p>
         -->
</ul>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

            </div>
            
        

        <!-- Content Column -->
        <div class="col-md-9" id="tg-sb-content">
            <div class="post-header">
   <h1 class="post-title-main">Docker网络管理</h1>
</div>



<div class="post-content">

   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    


    

   <h2 id="1-简介">1. 简介</h2>
<p>一般来说，一个网卡只能分配给一个名称空间。但是如果名称空间数量超过了实体网卡的数量，我们就需要模拟网卡。而linux内核中支持两种级别的模拟网卡，一种是二层设备，一种是三层设备。我们的物理网卡本来也就是二层设备，他就是一个工作在链路层，能封装物理报文的，实现在各设备网络之间实现报文转发的设备。而这个功能完全能够通过在Linux内核的功能，在二层之上虚拟设备的支持，创建虚拟网卡接口的，而且这种虚拟网卡很独特，他是成对儿出现的，可以模拟为一根网线的两头。一头插在一个主机之上，一头插在交换机之上。那就相当于让一个主机插到了交换机之上，而linux内核原生支持二层虚拟网桥设备，就是用软件来构建一个交换机，我们可以brctl来实现。那么，一个软件交换机，一个软件实现的虚拟机，也就是名称空间。内核自己创建一个网卡，一头分配给这个名称空间，一头分配给交换机，就相当于模拟了一个主机连接到交换机。同样的，如果你有两个名称空间，这两个名称空间都这么干。各自创建一个虚拟网卡，一个创建在交换机上，一个创建在名称空间上，实现了接入的机制。那么我们就能实现了网络连接功能，他们就好像连接到一个交换机上的两个主机。显然，如果他们两台机器配置的网络地址在同一个网段，就可以直接通信了。这就是所谓的虚拟化网络，从网络设备通信的物理设备到网卡都是用纯软件的方式实现，我们在一台主机上通过纯软件的方式来实现，所以我们把他叫做网络虚拟化技术当中的一种简单的实现。</p>

<p>有一个著名的应用程序，叫ovs（open vswitch），用纯软件的方式实现交换机，他还能模拟非常高级的三层网络设备才有的功能，比如：vlan，vxlan技术，gre技术，甚至是流控技术，就是SDN。完全用软件实现，功能非常强大。只不过他不属于linux内核模块本身的功能，我们需要额外安装这个软件。这个软件是由CISCO等众多专业的网络设备生产公司联合研发的软件，而目前在云计算的大潮之下，我们要构建一个云计算中心时，构建网络是非常复杂的工作，因为网络之上承载着主机，他们需要通信。而这个网络虚拟化实现的功能，需要软硬件结合起来，把传统意义上的网络平面，控制平面，传输平面剥离开来，实现将控制平面集中到一个专业的设备之上实现全局调度。也就是实现了SDN的机制。所以我们以后如果构建云计算中心的时候，不仅需要软件，还需要在硬件层面支持，在每一个主机之上构建出非常复杂的网络环境来，毕竟，在同一个网络之上，我们要运行多个主机或者多个容器，这每一个容器都需要用到网络。</p>

<h2 id="2-容器间通信">2. 容器间通信</h2>

<p>如果是在同一个物理机的两个容器，两个名称空间想通信，就在这同一个主机之上建立一个虚拟交换机，我们让两个容器或者名称空间各自用纯软件的方式建一对儿虚拟网卡，那么一半在容器上，一半在虚拟交换机上。如果我们有多个交换机怎么办，我们有两个软件交换机，交换机S1上的C1要和交换机上的C3通信怎么办</p>

<p><img src="https://graph.baidu.com/resource/222842583a8fcc4671c1001585582593.png" alt="file" /></p>

<p>刚才说过，我们可以在主机之上再做一对儿网卡，一个在S1上一个在S2上。但是，如果我们希望他们之间通过路由转发的话，我们就需要做一个路由。</p>

<p><img src="https://graph.baidu.com/resource/2226f88064c41a28c07d001585582769.png" alt="file" /></p>

<p>其实linux自己就可以当一个路由来使用，使用iptables规则，或者直接打开转发就可以了。路由器是三层设备，linux在内核级别，使用一个单独的名称空间就能支持。我们可以在做一个容器，容器里面只有路由一个功能。但是需要模拟出网卡，让他们建立关联关系。假如C1和C5想通信怎么办。</p>

<p>我们可以使用桥接，就是把物理网卡当做交换机来用，所有请求都到达物理网卡，然后根据桥接上来的机器的MAC地址，来判断请求应该转发给哪个主机。也就是说桥接上的机器的网卡必须有自己的MAC地址，而且不能和主机一样。这种通信代价很大，首先，你的所有容器都是桥接的，如果大家都在同一个网络平面，那么就很容易产生风暴，因此，在隔离上也是极其不容易的。在大规模的虚拟机或者虚拟机的场景中基本不可行，除非我们可以使用大二层的技术把他们隔离开来。</p>

<p><img src="https://graph.baidu.com/resource/222b60ecf8e945f6028c801585582895.png" alt="file" /></p>

<p>如果不桥接，而且能够实现跨主机通信，我们应该使用的是NAT技术。比如，C3想和C6通信，C3的网络地址和物理网卡的地址不在同一个网段，那么C3把网关指向S2，我们可以把S2当做网关来使用，给S2配置一个IP地址，跟C3在一个网段。然后在物理机上打开核心转发功能，所以C3跟C6通信时，先把请求送给S2，到达物理内核，物理机判定不是自己的地址，然后查路由经由物理网卡把请求送出去。但是报文回不来，因为C3是私有地址，我们最好在C3报文送走到S1之前要把源IP改成，H1主机的物理网卡的IP地址，这样C6回包的时候，就把请求回给物理机就好了，然后物理机拿到回报之后，发现不是自己的，查找网卡查路由表之后发现是C3访问的，然后把回包送给C3。就是SNAT。但是这里有个问题在于，H2的通信也是需要经由NAT来实现，就是两级NAT，C6也是私有地址，C6怎么能被C3看见呢？想要暴露自己，就必须要DNAT。在主机上的某一个端口提供服务，然后由这个端口映射给C6。也就是说，想要访问C6就必须访问H2的物理网卡地址，请求发给C6实际上是H2做的DNAT，把请求发送过去的。也就是说，请求出去要做SNAT，到达目标要做DNAT。C4和C6实际上是隔着两层来通信的，效率非常的低。</p>

<p><img src="https://graph.baidu.com/resource/222c27a8b4a07f9a1322301585582967.png" alt="file" /></p>

<p>而解决这种问题需要用到叠加网络，也是我们后面kubernetes中讲到的技术，overlay network。</p>

<p>简单来说，我们有物理机上面运行了虚拟机，物理机的物理网卡，同时在虚拟机上做一个虚拟的桥，让虚拟机的网卡都连接到这个桥上来，而接上来的网卡通过物理网卡的功能实现隧道转发，从而实现C1直接看到C5。那么，本来他们可以通信，而C1和物理网络不在同一地址段内，而和C5在同一地址段内，C1想要访问C5，但是物理网卡知道C5并不在本地服务器上，使得请求从C1出来之后，到达C5之前是这么转发报文的，要做隧道转发，就是C1的报文的源地址是C1，目标地址是C5，然后在报文上在封装一层，源地址是C1网卡的地址，目标地址是C5网卡的地址，所以C5的网卡拿到报文拆包之后发现，目标地址是C5，就直接把报文送给本地交换机，由软网桥转发。本来他应该是三层报文，但是通过叠加的方式，本来应该封装二层了，但是没有封装二层，而是重新封装一个三层四层报文，实现两级三层封装。</p>

<p><img src="https://graph.baidu.com/resource/222831d29c4b7f1b2e80501585625050.png" alt="file" /></p>

<h2 id="3-docker的网络">3. Docker的网络</h2>
<p>Docker安装完成后提供三种网络，bridge，host和none，默认是bridge，但是这个bridge不是物理桥，是NAT桥。他会创建一个纯粹的软交换机叫docker0，也可以当网卡使用，不给地址就是交换机，给地址既能当交换机，又能当网卡。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nt">-y</span> install bridge-utils

brctl show
bridge name	bridge id		STP enabled	interfaces
docker0		8000.0242800e4768	no

ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 02:58:a7:45:b5:b6 brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
    link/ether 02:42:80:0e:47:68 brd ff:ff:ff:ff:ff:ff
</code></pre></div></div>

<p>随后我们创建容器的时候，会创建一对儿网卡，一个放在虚拟机上，一个放在交换机上。我们看到的veth就是一对网卡的一半。我们可以使用brctl或者ip命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">-d</span> busybox

ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 02:58:a7:45:b5:b6 brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:80:0e:47:68 brd ff:ff:ff:ff:ff:ff
5: veth893bb3f@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether da:c2:8f:62:da:2e brd ff:ff:ff:ff:ff:ff link-netnsid 0
</code></pre></div></div>

<p>veth893bb3f@if4就是新创建的网卡，我们登陆到容器中，就可以看到另外一个网卡，使用ifconfig，而且可以ping通docker0。docker0是一个nat桥，每启动一个桥，他会自动生成一个iptables规则。可以使用iptables -t nat -vnL查看</p>

<p><img src="https://graph.baidu.com/resource/222b23725b4026e421d8b01585664881.png" alt="file" /></p>

<p>如果我们的容器内跑的是nginx，而nginx想被其他客户端访问，我们应该有下面几种来源</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> n1 <span class="nt">-d</span> nginx

docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
667558b5bcf2        nginx               <span class="s2">"nginx -g 'daemon of…"</span>   About a minute ago   Up About a minute   80/tcp              n1
9cdad181c82a        busybox             <span class="s2">"sh"</span>                     11 minutes ago       Up 11 minutes                           t1

</code></pre></div></div>

<ul>
  <li>如果是同一个主机上的同一个容器，另外一个容器也使用了桥接网络，他们可以直接通信</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker inspect 667558b5bcf2 |grep IPAddress
            <span class="s2">"SecondaryIPAddresses"</span>: null,
            <span class="s2">"IPAddress"</span>: <span class="s2">"172.17.0.3"</span>,
                    <span class="s2">"IPAddress"</span>: <span class="s2">"172.17.0.3"</span>,
</code></pre></div></div>

<p>在busybox上，使用<code class="highlighter-rouge">wget -O - -q http://172.17.0.3</code>，可以访问到nginx</p>

<ul>
  <li>
    <p>我们还可以从物理机上访问，使用“curl 172.17.0.2”也可以访问</p>
  </li>
  <li>
    <p>如果我们想从其他机器访问怎么办呢，我们就需要发布，做DNAT，在物理端口上启动一个端口来提供端口，而端口使用DNAT的方式转发到我们的容器中。也就是说我们创建任何的容器时，都会默认使用桥接的网络，如果想被访问，就需要添加一个DNAT规则，便于他被外部其他客户端访问。那么如果有两个容器，都需要使用80端口，我们就需要使用两个端口，而且一个必须是非80端口，但是这个是无解的。必须启用多个端口</p>
  </li>
  <li>
    <p>而如果容器需要访问容器，我们就可以通过另一种方式。我们容器内有6个名称空间，他们是互相独立的。</p>
  </li>
</ul>

<p><img src="https://graph.baidu.com/resource/222189c7d9fa222b9702e01585627185.png" alt="file" /></p>

<p>为了让他们能从内部访问，我们可以这样设计。把User，Mount和Pid独立，UTS，Net和IPC共享，就形成了下面的形式。</p>

<p><img src="https://graph.baidu.com/resource/22278fc03fe0f8537efd401585627175.png" alt="file" /></p>

<ul>
  <li>
    <p>那么，物理机上是不是也有一个名称空间。我们是不是也可以使用物理机的名称空间呢？必须可以。我们对于第三种情况，还有一个这种的办法，就是把一个容器暴露出来，而把另外一个使用物理的名称空间。这种就叫host方式。</p>
  </li>
  <li>
    <p>最后一种方式，就是none，就是没有网卡，没有网络。比如：我们有可能只需要加载一些数据，处理之后就销毁，这样根本不需要网络。</p>
  </li>
</ul>

<p>其实就是下面这4中网络模型</p>

<p><img src="https://graph.baidu.com/resource/222a753d504ba2b0f5ffd01585627544.png" alt="file" /></p>

<p>这四种类型，第一个是，只创建一个lo接口，而不用和其他的容器通信，第二个创建两个接口，一半在容器上，一半在docker0桥上。可以通过brctl来实现，第三种是一个容器加入了一个容器，先创建一个容器A，然后再创建容器B去共享A的一部分空间，叫联盟容器。最后一个，容器共享的是主机的名称空间。</p>

<ul>
  <li>最后，我们在创建的时候，需要指定网络类型，就使用
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container run <span class="nt">--network</span> XXXX
</code></pre></div>    </div>
    <p>查看网络类型就使用</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network <span class="nb">ls
</span>NETWORK ID          NAME                DRIVER              SCOPE
08676b91ca7c        bridge              bridge              <span class="nb">local
</span>782b9a1ab54d        host                host                <span class="nb">local
</span>86960aa7fb1d        none                null                <span class="nb">local</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>查看网桥的具体信息可以使用下面的命令，这些信息我们是可以修改的，我们后面继续讲</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network inspect bridge
</code></pre></div></div>

<h2 id="4-手动添加网络名称空间">4 手动添加网络名称空间</h2>
<p>我们可以使用ip netns来模拟docker管理网络名称空间，当我们使用IP来创建网络名称空间的时候，只有网络名称空间是隔离的，其他都是共享的。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns add r1
ip netns add r2
ip netns list
r2
r1
</code></pre></div></div>

<p>如果我们没有单独给他们指定网卡，他们应该只有一个网卡lo</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r1 ifconfig <span class="nt">-a</span>
lo: <span class="nv">flags</span><span class="o">=</span>8&lt;LOOPBACK&gt;  mtu 65536
        loop  txqueuelen 1000  <span class="o">(</span>Local Loopback<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>我们可以使用ip命令创建虚拟网卡对，然后人工分配到网络名称空间中</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link add name veth1.1 <span class="nb">type </span>veth peer name veth1.2
</code></pre></div></div>

<p>查看网卡，会看到两个网卡</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link show
<span class="nb">.</span>
<span class="nb">.</span>
<span class="nb">.</span>
10: veth1.2@veth1.1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether d2:2b:e6:bf:b5:73 brd ff:ff:ff:ff:ff:ff
11: veth1.1@veth1.2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 9a:24:a4:50:be:21 brd ff:ff:ff:ff:ff:ff
</code></pre></div></div>

<p>但是这两个网卡都没有被激活，ifconfig看不见，我们需要把其中一个挪到创建的网络名称空间当中去</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link <span class="nb">set </span>dev veth1.2 netns r1
</code></pre></div></div>
<p>再看，会少一个网卡</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link show
<span class="nb">.</span>
<span class="nb">.</span>
<span class="nb">.</span>
11: veth1.1@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 9a:24:a4:50:be:21 brd ff:ff:ff:ff:ff:ff link-netnsid 2
</code></pre></div></div>

<p>然后到r1中去看</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r1 ifconfig <span class="nt">-a</span>
lo: <span class="nv">flags</span><span class="o">=</span>8&lt;LOOPBACK&gt;  mtu 65536
        loop  txqueuelen 1000  <span class="o">(</span>Local Loopback<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth1.2: <span class="nv">flags</span><span class="o">=</span>4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500
        ether d2:2b:e6:bf:b5:73  txqueuelen 1000  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>我们还可以改名</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r1 ip link <span class="nb">set </span>dev veth1.2 name eth0
</code></pre></div></div>

<p>发现名称变了</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r1 ifconfig <span class="nt">-a</span>
eth0: <span class="nv">flags</span><span class="o">=</span>4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500
        ether d2:2b:e6:bf:b5:73  txqueuelen 1000  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: <span class="nv">flags</span><span class="o">=</span>8&lt;LOOPBACK&gt;  mtu 65536
        loop  txqueuelen 1000  <span class="o">(</span>Local Loopback<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>然后激活他们就可以通信了，先激活宿主机上的</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifconfig veth1.1 10.1.0.1/24 up
</code></pre></div></div>

<p>再把r1中的激活</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r1 ifconfig eth0 10.1.0.2/24 up
</code></pre></div></div>

<p>查看连接</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping 10.1.0.2
</code></pre></div></div>

<p>我们也可以把宿主机上的那个送给r2，就好像r2和r1在通信</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip link <span class="nb">set </span>dev veth1.1 netns r2
</code></pre></div></div>

<p>在看主机上的网卡，veth1.1就消失了</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifconfig
</code></pre></div></div>

<p>跑到了r2上</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r2 ifconfig <span class="nt">-a</span>
lo: <span class="nv">flags</span><span class="o">=</span>8&lt;LOOPBACK&gt;  mtu 65536
        loop  txqueuelen 1000  <span class="o">(</span>Local Loopback<span class="o">)</span>
        RX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth1.1: <span class="nv">flags</span><span class="o">=</span>4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500
        ether 9a:24:a4:50:be:21  txqueuelen 1000  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 11  bytes 866 <span class="o">(</span>866.0 B<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 11  bytes 866 <span class="o">(</span>866.0 B<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>默认是没有激活的，我们再手动激活</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r2 ifconfig veth1.1 10.1.0.3/24 up
</code></pre></div></div>

<p>发现IP地址已经有了</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r2 ifconfig
veth1.1: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 10.1.0.3  netmask 255.255.255.0  broadcast 10.1.0.255
        inet6 fe80::9824:a4ff:fe50:be21  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 9a:24:a4:50:be:21  txqueuelen 1000  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 13  bytes 1046 <span class="o">(</span>1.0 KiB<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 17  bytes 1382 <span class="o">(</span>1.3 KiB<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>我们在r2中ping r1</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip netns <span class="nb">exec </span>r2 ping 10.1.0.2
</code></pre></div></div>

<p>也是没问题的</p>

<h2 id="5-创建容器的时候指定一些网络选项">5 创建容器的时候指定一些网络选项</h2>

<p>创建的容器使用bridge网络</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>
<p>或者</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>

<p>创建none网络的容器</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--network</span> none <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>

<p>默认创建的容器，主机名就是容器的ID号，我们可以改，但是我们一般会使用–h选项，在创建的时候就注入主机名</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-h</span> t1.jormun.com <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>

<p>如果我们还需要使用主机名作为dns名称而被访问，那么有两种方式，第一是主机名可以被解析，通过DNS或者本地hosts文件，hosts文件中是没问题的，但是resolve文件会把nameserver指向我们的物理机上使用的解析服务器</p>

<p>使用nslookup -type=A www.baidu.com</p>

<p>如果我们的宿主机没有dns服务器怎么办呢？我们可以在创建容器的时候指定dns服务器，–dns和–dns-search</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-h</span> t1.jormun.com  <span class="nt">--dns</span> 114.114.114.114 <span class="nt">--dns-search</span> jormun.com <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>

<p>我们还可以修改hosts的记录，通过–add-hosts来外部注入</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t1 <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-h</span> t1.jormun.com  <span class="nt">--dns</span> 114.114.114.114 <span class="nt">--dns-search</span> jormun.com <span class="nt">--add-hosts</span> www.jormun.com:1.1.1.1 <span class="nt">--rm</span> busybox:latest
</code></pre></div></div>

<h2 id="6-开放入栈的通信">6 开放入栈的通信</h2>

<p>我们使用nginx的时候，nginx是隐藏在docker0之后的，一般来说，从外部访问是不可达的。我们需要主动发布，或者暴露到对外通信的网络，叫expose，使用-p选项，他的方式有4种</p>

<ul>
  <li>-p containerPort：将指定的容器端口映射至主机所有地址的一个动态端口，也就是一个30000以上的随机端口，假如我们在一个机器上运行多个nginx，使用这种方式不会产生冲突
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> web <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-p</span> 80 <span class="nt">--rm</span> nginx
</code></pre></div>    </div>
  </li>
</ul>

<p>我们可以使用iptables -t nat -vnL生成的规则也可以使用docker port web来查看，我们发现，这个是监听在所有地址上的。</p>

<ul>
  <li>-p hostPort:containerPort：将容器端口containerPort映射至指定的主机端口hostPort
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> web <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-p</span> 80:80 <span class="nt">--rm</span> nginx
</code></pre></div>    </div>
  </li>
</ul>

<p>使用docker port web来查看，我们发现，这个是监听在任意地址的80端口上的</p>

<ul>
  <li>-p ip::containerPort：将指定的容器端口containerPort映射至主机指定ip的动态端口
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> web <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-p</span> 宿主机的IP::80 <span class="nt">--rm</span> nginx
</code></pre></div>    </div>
  </li>
</ul>

<p>使用docker port web来查看，我们发现，这个是监听在宿主机的IP上的</p>

<ul>
  <li>-p ip:hostPort:containerPort：将指定的容器端口containerPort映射至主机指定ip的端口hostPort
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> web <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-p</span> 宿主机的IP:80:80 <span class="nt">--rm</span> nginx
</code></pre></div>    </div>
  </li>
</ul>

<p>使用docker port web来查看，我们发现，这个是监听在宿主机的IP上的80端口的</p>

<ul>
  <li>而我们也可以多次使用-p 选项来暴露多个端口
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> web <span class="nt">-it</span> <span class="nt">--network</span> bridge <span class="nt">-p</span> 宿主机的IP:80:80 <span class="nt">--rm</span> nginx
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="7-联盟式容器">7. 联盟式容器</h2>

<p>我们使用交互式启动一个容器</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> b1 <span class="nt">-it</span> <span class="nt">--rm</span> busybox
</code></pre></div></div>

<p>然后启动第二个容器的时候使用 –network选项共享b1的网络名称空间</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> b2 <span class="nt">--network</span> container:b1 <span class="nt">-it</span> <span class="nt">--rm</span> busybox
</code></pre></div></div>

<p>但是他们的目录不是共享的，我们可以通过创建一个文件来验证一下，而他们的网络是共享的</p>

<p>在一个运行</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"hello"</span> <span class="o">&gt;</span> /tmp/index.html
httpd <span class="nt">-h</span> /tmp/
netstat <span class="nt">-tnl</span>
</code></pre></div></div>
<p>在另一个上</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-O</span> - <span class="nt">-q</span> 127.0.0.1
</code></pre></div></div>

<h2 id="7-host容器">7. host容器</h2>

<p>docker run –name b2 –network host -it –rm busybox</p>

<p>我们用ifconfig就会发现自己使用的是主机的网络</p>

<p>此时，如果我们启动一个http服务器，会发现他监听的端口就是本机的端口</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"hello"</span> <span class="o">&gt;</span> /tmp/index.html
httpd <span class="nt">-h</span> /tmp/
netstat <span class="nt">-tnl</span>
</code></pre></div></div>

<h2 id="8-自定义docker网桥">8. 自定义docker网桥</h2>
<h3 id="81-修改docker0桥的网络属性信息">8.1. 修改docker0桥的网络属性信息</h3>

<p>需要修改/etc/docker/daemon.json</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
“bip”: <span class="s2">"192.168.1.5./24"</span>,
<span class="s2">"fixed-cidr"</span>:<span class="s2">"10.20.0.0/16"</span>,
<span class="s2">"fixed-cird-v6"</span>:<span class="s2">"2001:db8::/64"</span>,
<span class="s2">"mtu"</span>:1500,
<span class="s2">"default-gateway"</span>:<span class="s2">"10.20.1.1"</span>,
<span class="s2">"default-gateway-v6"</span>:<span class="s2">"2001:db8:abcd::89"</span>,
<span class="s2">"dns"</span>:[<span class="s2">"10.20.1.2"</span>,<span class="s2">"10.20.1.3"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="82-修改客户端和服务器通讯的地址">8.2. 修改客户端和服务器通讯的地址</h3>
<p>默认是/var/run/docker.sock，我们可以使用-H选项来指定docker去连接哪个docker服务器，而我们的服务器也需要暴露端口，需要修改/etc/docker/daemon.json</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>“hosts”:[<span class="s2">"tcp://0.0.0.0:2375"</span>,<span class="s2">"unix:///var/run/docker.sock"</span><span class="o">]</span>
</code></pre></div></div>
<p>或者在dockerd启动的时候传递 -H选项</p>

<h3 id="83-创建一个自定的桥">8.3. 创建一个自定的桥</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create <span class="nt">-d</span> bridge <span class="nt">--subnet</span> <span class="s2">"172.26.0.0/16"</span> <span class="nt">--gateway</span> <span class="s2">"172.26.0.1"</span> mybr0
f0aa13b02d9874cfb4656a5362094387f5a4c29e74a89a6e27363e4519e34e28

docker network <span class="nb">ls
</span>NETWORK ID          NAME                DRIVER              SCOPE
08676b91ca7c        bridge              bridge              <span class="nb">local
</span>782b9a1ab54d        host                host                <span class="nb">local
</span>f0aa13b02d98        mybr0               bridge              <span class="nb">local
</span>86960aa7fb1d        none                null                <span class="nb">local</span>
</code></pre></div></div>

<p>ifconfig可以看到一个新的接口</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifconfig
br-f0aa13b02d98: <span class="nv">flags</span><span class="o">=</span>4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.26.0.1  netmask 255.255.0.0  broadcast 172.26.255.255
        ether 02:42:fd:25:e4:4a  txqueuelen 0  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 7  bytes 1272 <span class="o">(</span>1.2 KiB<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 25  bytes 1844 <span class="o">(</span>1.8 KiB<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre></div></div>

<p>我们在创建容器的时候就可以让他加入mybr0</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> t3 <span class="nt">-it</span> <span class="nt">--net</span> mybr0 busybox
/ <span class="c"># ifconfig</span>
eth0      Link encap:Ethernet  HWaddr 02:42:AC:1A:00:02
          inet addr:172.26.0.2  Bcast:172.26.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1032 <span class="o">(</span>1.0 KiB<span class="o">)</span>  TX bytes:0 <span class="o">(</span>0.0 B<span class="o">)</span>

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 <span class="o">(</span>0.0 B<span class="o">)</span>  TX bytes:0 <span class="o">(</span>0.0 B<span class="o">)</span>

</code></pre></div></div>


    <div class="tags">
        
    </div>


<div id="commento"></div>
<script src="https://cdn.commento.io/js/commento.js"></script>
<noscript>Please enable JavaScript to load the comments.</noscript>



</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2020 原生云技术. All rights reserved. <br />
 Site last generated: Jun 29, 2020 <br />
<p><img src="images/company_logo.png" alt="Company logo"/></p>
                </div>
            </div>
</footer>


        </div>
    <!-- /.row -->
</div>
<!-- /.container -->
</div>
<!-- /#main -->
    </div>

</body>

</html>
