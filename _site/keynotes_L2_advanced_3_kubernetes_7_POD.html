<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" keynotes, advanced, kubernetes, CKA, POD">
<title>POD | CloudNative knowledge</title>
<link rel="stylesheet" href="css/syntax.css">

<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/boxshadowproperties.css">
<!-- most color styles are extracted out to here -->
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Anchor.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="cloudnative365.gitpage.io" href="http://0.0.0.0:4000/feed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    <script>
        $(document).ready(function() {
            $("#tg-sb-link").click(function() {
                $("#tg-sb-sidebar").toggle();
                $("#tg-sb-content").toggleClass('col-md-9');
                $("#tg-sb-content").toggleClass('col-md-12');
                $("#tg-sb-icon").toggleClass('fa-toggle-on');
                $("#tg-sb-icon").toggleClass('fa-toggle-off');
            });
        });
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-static-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> 云原生技术课堂</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- toggle sidebar button -->
                <li><a id="tg-sb-link" href="#"><i id="tg-sb-icon" class="fa fa-toggle-on"></i> Nav</a></li>
                <!-- entries without drop-downs appear here -->




                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课程<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="lessons_syllabus.html">教学大纲</a></li>
                        
                        
                        
                        <li><a href="lessons_plans.html">开课计划</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课堂笔记<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="keynotes_L1_basic.html">基础课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L2_advanced.html">进阶课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L3_senior.html">高级课程</a></li>
                        
                        
                        
                        <li><a href="keynotes_L4_architect.html">架构师课程</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">课堂风采<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="classes_teachers.html">讲师风采</a></li>
                        
                        
                        
                        <li><a href="classes_aboutus.html">关于我们</a></li>
                        
                        
                        
                        <li><a href="classes_successd.html">优秀学员作品</a></li>
                        
                        
                    </ul>
                </li>
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">常用链接<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="https://www.cncf.io/" target="_blank" rel="noopener">CNCF Foundation</a></li>
                        
                        
                        
                        <li><a href="https://www.linuxfoundation.org/" target="_blank" rel="noopener">Linux Foundation</a></li>
                        
                        
                        
                        <li><a href="https://cd.foundation/" target="_blank" rel="noopener">CD Foundation</a></li>
                        
                        
                    </ul>
                </li>
                
                
                
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="POD">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
  <div id="main">
    <!-- Content Row -->
    <div class="row">
        
        
            <!-- Sidebar Column -->
            <div class="col-md-3" id="tg-sb-sidebar">
                

<ul id="mysidebar" class="nav">
  <li class="sidebarTitle">进阶课程 </li>
  
  
  
      
  
  <li>
      <a title="第一章 CKA官方教程" href="#">第一章 CKA官方教程</a>
      <ul>
          
          
          
          <li><a title="1 COURSE_INTRODUCTION" href="keynotes_L2_advanced_1_kubernetes_1_CKA_1_COURSE_INTRODUCTION.html">1 COURSE_INTRODUCTION</a></li>
          
          
          
          
          
          
          <li><a title="2 BASICS_OF_KUBERNETES" href="keynotes_L2_advanced_1_kubernetes_1_CKA_2_BASICS_OF_KUBERNETES.html">2 BASICS_OF_KUBERNETES</a></li>
          
          
          
          
          
          
          <li><a title="3 INSTALLATION_AND_CONFIGURATION" href="keynotes_L2_advanced_1_kubernetes_1_CKA_3_INSTALLATION_AND_CONFIGURATION.html">3 INSTALLATION_AND_CONFIGURATION</a></li>
          
          
          
          
          
          
          <li><a title="4 KUBERNETES_ARCHITECTURE" href="keynotes_L2_advanced_1_kubernetes_1_CKA_4_KUBERNETES_ARCHITECTURE.html">4 KUBERNETES_ARCHITECTURE</a></li>
          
          
          
          
          
          
          <li><a title="5 APIS_AND_ACCESS" href="keynotes_L2_advanced_1_kubernetes_1_CKA_5_APIS_AND_ACCESS.html">5 APIS_AND_ACCESS</a></li>
          
          
          
          
          
          
          <li><a title="6 API_OBJECTS" href="keynotes_L2_advanced_1_kubernetes_1_CKA_6_API_OBJECTS.html">6 API_OBJECTS</a></li>
          
          
          
          
          
          
          <li><a title="7 MANAGING_STATE_WITH_DEPLOYMENTS" href="keynotes_L2_advanced_1_kubernetes_1_CKA_7_MANAGING_STATE_WITH_DEPLOYMENTS.html">7 MANAGING_STATE_WITH_DEPLOYMENTS</a></li>
          
          
          
          
          
          
          <li><a title="8 SERVICES" href="keynotes_L2_advanced_1_kubernetes_1_CKA_8_SERVICES.html">8 SERVICES</a></li>
          
          
          
          
          
          
          <li><a title="9 VOLUMES_AND_DATA" href="keynotes_L2_advanced_1_kubernetes_1_CKA_9_VOLUMES_AND_DATA.html">9 VOLUMES_AND_DATA</a></li>
          
          
          
          
          
          
          <li><a title="10 INGRESS" href="keynotes_L2_advanced_1_kubernetes_1_CKA_10_INGRESS.html">10 INGRESS</a></li>
          
          
          
          
          
          
          <li><a title="11 SCHEDULING" href="keynotes_L2_advanced_1_kubernetes_1_CKA_11_SCHEDULING.html">11 SCHEDULING</a></li>
          
          
          
          
          
          
          <li><a title="12 LOGGING_AND_TROUBLESHOOTING" href="keynotes_L2_advanced_1_kubernetes_1_CKA_12_LOGGING_AND_TROUBLESHOOTING.html">12 LOGGING_AND_TROUBLESHOOTING</a></li>
          
          
          
          
          
          
          <li><a title="13 CUSTOM_RESOURCE_DEFINITIONS" href="keynotes_L2_advanced_1_kubernetes_1_CKA_13_CUSTOM_RESOURCE_DEFINITIONS.html">13 CUSTOM_RESOURCE_DEFINITIONS</a></li>
          
          
          
          
          
          
          <li><a title="14 HELM" href="keynotes_L2_advanced_1_kubernetes_1_CKA_14_HELM.html">14 HELM</a></li>
          
          
          
          
          
          
          <li><a title="15 SECURITY" href="keynotes_L2_advanced_1_kubernetes_1_CKA_15_SECURITY.html">15 SECURITY</a></li>
          
          
          
          
          
          
          <li><a title="16 HIGH_AVAILABILITY" href="keynotes_L2_advanced_1_kubernetes_1_CKA_16_HIGH_AVAILABILITY.html">16 HIGH_AVAILABILITY</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="第二章 CKAD官方教程" href="#">第二章 CKAD官方教程</a>
      <ul>
          
          
          
          <li><a title="CloudNative Roadmap" href="mydoc_release_notes_60.html">CloudNative Roadmap</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="第三章 kubernetes入门讲座" href="#">第三章 kubernetes入门讲座</a>
      <ul>
          
          
          
          <li><a title="1. 课程介绍" href="keynotes_L2_advanced_3_kubernetes_1_COURSE_INTRODUCTION.html">1. 课程介绍</a></li>
          
          
          
          
          
          
          <li><a title="2. 认识kubernetes" href="keynotes_L2_advanced_3_kubernetes_2_BASICS_OF_KUBERNETES.html">2. 认识kubernetes</a></li>
          
          
          
          
          
          
          <li><a title="3. kubernetes架构和基础概念" href="keynotes_L2_advanced_3_kubernetes_3_KUBERNETES_ARCHITECTURE.html">3. kubernetes架构和基础概念</a></li>
          
          
          
          
          
          
          <li><a title="4. 安装和配置kubernetes实验环境" href="keynotes_L2_advanced_3_kubernetes_4_INSTALLATION_AND_CONFIGURATION.html">4. 安装和配置kubernetes实验环境</a></li>
          
          
          
          
          
          
          <li><a title="5. 使用命令行管理资源" href="keynotes_L2_advanced_3_kubernetes_5_MANAGE_RESOURCES_WITH_CMD.html">5. 使用命令行管理资源</a></li>
          
          
          
          
          
          
          <li><a title="6. 使用清单文件管理资源" href="keynotes_L2_advanced_3_kubernetes_6_MANAGE_RESOURCES_WITH_MANIFEST.html">6. 使用清单文件管理资源</a></li>
          
          
          
          
          
          
          <li class="active"><a title="7. POD" href="keynotes_L2_advanced_3_kubernetes_7_POD.html">7. POD</a></li>
          
          
          
          
          
          
          <li><a title="8. 标签和标签选择器" href="keynotes_L2_advanced_3_kubernetes_8_LABEL_AND_SELECTOR.html">8. 标签和标签选择器</a></li>
          
          
          
          
          
          
          <li><a title="9. Deployment" href="keynotes_L2_advanced_3_kubernetes_9_CONTROLLER.html">9. Deployment</a></li>
          
          
          
          
          
          
          <li><a title="10. Service" href="keynotes_L2_advanced_3_kubernetes_10_SERVICE.html">10. Service</a></li>
          
          
          
          
          
          
          <li><a title="11. pv" href="keynotes_L2_advanced_3_kubernetes_11_PV.html">11. pv</a></li>
          
          
          
          
          
          
          <li><a title="12. configmap和secret" href="keynotes_L2_advanced_3_kubernetes_12_SECRET_AND_CONFIGMAP.html">12. configmap和secret</a></li>
          
          
          
          
          
          
          <li><a title="13. API" href="keynotes_L2_advanced_3_kubernetes_13_APIS_AND_ACCESS.html">13. API</a></li>
          
          
          
          
          
          
          <li><a title="14. STATEFULSET" href="keynotes_L2_advanced_3_kubernetes_14_STATEFULSET.html">14. STATEFULSET</a></li>
          
          
          
          
          
          
          <li><a title="15. INGRESS" href="keynotes_L2_advanced_3_kubernetes_15_INGRESS.html">15. INGRESS</a></li>
          
          
          
          
          
          
          <li><a title="16. 调度" href="keynotes_L2_advanced_3_kubernetes_16_SCHEDULING.html">16. 调度</a></li>
          
          
          
          
          
          
          <li><a title="17. 日志和错误定位" href="keynotes_L2_advanced_3_kubernetes_17_LOGGING_AND_TROUBLESHOOTING.html">17. 日志和错误定位</a></li>
          
          
          
          
          
          
          <li><a title="18. 自定义资源" href="keynotes_L2_advanced_3_kubernetes_18_CUSTOM_RESOURCE_DEFINTIONS.html">18. 自定义资源</a></li>
          
          
          
          
          
          
          <li><a title="19. HELM" href="keynotes_L2_advanced_3_kubernetes_19_HELM.html">19. HELM</a></li>
          
          
          
          
          
          
          <li><a title="20. SECURITY" href="keynotes_L2_advanced_3_kubernetes_20_SECURITY.html">20. SECURITY</a></li>
          
          
          
          
      </ul>
   </li>
     
      
      
      <!-- if you aren't using the accordion, uncomment this block:
         <p class="external">
             <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
         </p>
         -->
</ul>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

            </div>
            
        

        <!-- Content Column -->
        <div class="col-md-9" id="tg-sb-content">
            <div class="post-header">
   <h1 class="post-title-main">POD</h1>
</div>



<div class="post-content">

   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    


    

   <h2 id="课程目标">课程目标</h2>
<ul>
  <li>POD基本概念</li>
  <li>POD生命周期</li>
  <li>initContainer</li>
  <li>
    <p>容器探针Probe</p>
  </li>
  <li>Pod重启的原因</li>
</ul>

<h2 id="1-pod基本概念">1. POD基本概念</h2>
<p>我们首先创建一个最基本的pod</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: v1
kind: Pod
metadata:
  name: pod-demo
spec:
  containers:
	- name: myapp
	  image: jocatalin/kubernetes-bootcamp:v1
</code></pre></div></div>
<p>Kubernetes编排的主要对象就是编排容器的生命周期。我们不单独和某一个容器去交互，而是使用另外一个最小容器单元Pod进行编排。考虑到Pod内的资源是共享的，我们通常把pod内部设计成只运行一个主要进程。</p>

<h3 id="11-pod与微服务">1.1. POD与微服务</h3>

<p><img src="/pages/keynotes/L2_advanced/3_kubernetes/pics/7_POD/image-20200420154642789.png" alt="image-20200420154642789" /></p>

<p>这张图用交通工具描述了传统架构和微服务架构的优缺点</p>

<ul>
  <li>左侧第一张图描述的是我们传统的应用，他的特点是负载量很大，所有的应用都跑在一个非常庞大的操作系统之上。就好像公交车，公交车上载着上班族们去上班。</li>
  <li>左侧第二张图描述的是如果这个系统宕机了，我们想要修复他，就需要花费大量的资金去修复整个系统，会有很长的宕机时间，服务的空档期很长，不灵活。如果用公交来比喻他的话，还会引起交通堵塞。</li>
  <li>右侧第一张图就是使用的微服务架构来解决这个问题，我们上班使用电动滑板车就可以了。每个人都有自己的电动滑板车。这样就降低了更换的成本，即使出现宕机，也不会影响整个系统的可用性。他的服务对象也非常广泛，任何人都可以使用，也不会引起交通堵塞。</li>
  <li>右侧第二张图是说，他的版本可以是不同的版本，满足客户多种需求，即使某一个节点宕机了，也不会影响系统可用性</li>
</ul>

<h3 id="12-多容器的pod">1.2. 多容器的POD</h3>

<p>我们一般会在一个pod中部署一个容器，如果有多容器的pod，另外一个容器一般是日志容器。我们把这种辅助容器叫做sidecar。sidecar的作用一般来说都是帮助主容器完成一些任务，而不影响主容器内应用的。那么，官方把这种辅助容器分成了三种</p>

<ul>
  <li>sidecar：日志类的辅助容器，当我们需要添加一些主容器中没有的功能的时候，我们会使用sidecar模式，这样既不会改变原有程序的代码，添加一些部署中不需要的东西，我们的容器还可以扩展原有容器的功能，并且保持了解耦和扩展性。比如：filebeats，logstash，fluentd，fluent-bit，exporter</li>
  <li>ambassador：这有两重含义，一个是指微服务架构上的API gateway模式，比如envoy（Istio的代理），spring cloud gateway或者是更早的Zuul这类微服务治理相关软件所使用的模式，他们不使用kubenetes自身提供的代理功能，而是使用容器内部的代理来转发请求。我们以后讲Istio的时候再说这类微服务治理相关的知识。而另一重含义就是软件 ambassador，他同样是一款微服务治理软件，和Linkerd一样，都是这类软件的后期之秀。</li>
  <li>adapter：这种容器的作用是修改入栈和出栈的数据来满足我们其他的需求。举例来说，我们有一个非常专业的监控系统，这个监控系统的数据格式要求非常特殊。想获得这种格式化之后的数据，我们通常会借助adapter模式，这是最有效的方式去格式化主容器所产生的监控数据，而不是去修改监控系统本身或者已经容器化的应用。adapter容器用来把多种应用都输出成统一的格式。</li>
</ul>

<h3 id="13-多容器pod的结构">1.3. 多容器pod的结构</h3>

<p><img src="/pages/keynotes/L2_advanced/3_kubernetes/pics/7_POD/bfd5haac3htu-Kubernetes-Network-Pod-2.png" alt="Pod Network" /></p>

<p>多个容器共享同一个共同的<strong>网络名称空间</strong>。共享底层的net，uts和ipc三个网络名称空间，但是，另外三个，互相隔离。user，pid，mnt。这样一来，一个pod内的多个容器，共享主机名之类的名称空间，他更像是一个宿主机上运行了多个虚拟机。一个宿主机上运行了多个虚拟机，这个虚拟机上运行了应用程序，这些虚拟机使用同一个IPC（inter-process communication），或者lo接口，或者共同的文件系统进行通讯。这就是kubernes在组织容器的时候，使用的一个非常精巧的办法，使得我们可以构建较为精细的容器间通讯了。</p>

<p>同一个pod内的容器还共享第二个资源，<strong>存储卷</strong>，假如我们定义了一个存储卷，让第一个容器可以访问，那么，第二个容器也同样可以访问。存储卷不再属于容器，而属于pod。</p>

<p>原生的kubernetes当中，一个pod只有一个IP地址。这个地址由Pause容器来管理的。或者我们也可以理解为所有的pod其实都是多容器pod，只不过有一个默认的容器叫PAUSE。也有组织在研发多个IP地址的pod，目前只有vmware公司在开发具有多个IP地址的POD。不过这种需求不是很多，我们就不详细讨论这个了。</p>

<h3 id="14-容器的对外通信">1.4. 容器的对外通信</h3>

<p><img src="/pages/keynotes/L2_advanced/3_kubernetes/pics/7_POD/w7eqx8n15cor-ContainerNetwork.png" alt="Container Network" /></p>

<p>即使有两个容器，它们共享相同的名称空间和相同的IP地址，这将由kubectl与kube-proxy一起配置。IP地址在容器启动之前分配，会被插入到容器中。容器将有一个类似于<strong>eth0@tun10</strong>的接口。这个IP是根据pod的生命周期而存在的。</p>

<p>endpoint与service同时创建。注意，它使用pod IP地址，但也包括一个端口。该服务使用ipv中的iptables将网络流量从节点高位端口连接到端点。kube-controller管理器处理监视循环，以监视端点和服务以及任何更新或删除的需要。</p>

<h2 id="2-pod生命周期">2. POD生命周期</h2>

<p>对pod来说，从创建到结束有一个完整的生命周期。在pod创建的时候，有一个初始化的过程，在pod启动之前有一个过程，我们虽然称容器为秒级启动，但是应用程序自身的初始化可能就需要很多时间。</p>

<p>pod内的主容器在运行之前需要做一些环境设定，一般来说，主容器在启动之前的时间，我们可以用来做别的事，比如我们运行另外一个容器，这个容器专门为我们的主容器做环境初始化，这个容器叫initContainer。初始化容器从他的代码开始执行，到执行完毕，他就可以退出了，不会一直存在。而且，初始化容器可以有多个，而多个初始化容器会串行执行。等最后一个初始化容器执行完毕，主容器才会启动。</p>

<p>主容器在执行的时候可能也需要一些初始化，比如entry point，加载配置文件。而主容器在刚刚启动的时候，用户还可以嵌入一些操作，叫post start，这个命令只执行一次，执行完成就退出。在结束之前，也可以做一些操作，我们叫pre stop。无论是启动后，还是结束前的命令，我们称他们为hook，钩子，勾住一些命令来执行。</p>

<p>在整个主容器的运行过程中，我们还有两类操作，health check，他会在post start执行完成之后，会执行liveness probe。我们说过程序运行并不一定代表程序是健康的，也许他早就已经陷入了死循环，不能提供服务，但是他并不会退出。每一个pod内，我们需要对主容器的健康与否和就绪与否做监测，分别叫liveness probe和readiness probe。</p>

<p><img src="/pages/keynotes/L2_advanced/3_kubernetes/pics/7_POD/POD_LIFE.jpg" alt="img" /></p>

<h3 id="21-pod的运行阶段phase">2.1. POD的运行阶段（phase）</h3>

<p>Pod 的 <code class="highlighter-rouge">status</code> 定义在 <code class="highlighter-rouge">PodStatus</code> 对象中，其中有一个 <code class="highlighter-rouge">phase</code> 字段。</p>

<p>Pod 的运行阶段（phase）是 Pod 在其生命周期中的简单宏观概述。该阶段并不是对容器或 Pod 的综合汇总，也不是为了做为综合状态机制。</p>

<p>Pod 相位的数量和含义是严格指定的。除了本文档中列举的内容外，不应该再假定 Pod 有其他的 <code class="highlighter-rouge">phase</code> 值。</p>

<p>下面是 <code class="highlighter-rouge">phase</code> 可能的值：</p>

<ul>
  <li>挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。</li>
  <li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</li>
  <li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。</li>
  <li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</li>
  <li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>

<p><img src="/pages/keynotes/L2_advanced/3_kubernetes/pics/7_POD/u=1753021737,3638443276&amp;fm=26&amp;gp=0.jpg" alt="img" /></p>

<h3 id="22-pod的存活时间lifetime">2.2. POD的存活时间（lifetime）</h3>

<p>一般来说，Pod 不会消失，除非人为销毁他们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 phase 超过一段时间（由 master 确定）的Pod将过期并被自动销毁。也就是说，如果pod启动失败，控制器会尝试重新启动pod，再失败，再重新启动，而且每次从失败到重新启动的时间间隔，都会比上一次长。最长是5分钟。</p>

<p>有三种可用的控制器：</p>

<ul>
  <li>
    <p>使用 Job 运行预期会终止的 Pod，例如批量计算。Job 仅适用于重启策略为 OnFailure 或 Never 的 Pod。</p>
  </li>
  <li>
    <p>对预期不会终止的 Pod 使用 ReplicationController、ReplicaSet 和 Deployment ，例如 Web 服务器。 ReplicationController 仅适用于具有 restartPolicy 为 Always 的 Pod。</p>
  </li>
  <li>
    <p>提供特定于机器的系统服务，使用 DaemonSet 为每台机器运行一个 Pod 。</p>
  </li>
</ul>

<p>所有这三种类型的控制器都包含一个 PodTemplate。建议创建适当的控制器，让它们来创建 Pod，而不是直接自己创建 Pod。这是因为单独的 Pod 在机器故障的情况下没有办法自动复原，而控制器却可以。</p>

<p>如果节点死亡或与集群的其余部分断开连接，则 Kubernetes 将应用一个策略将丢失节点上的所有 Pod 的 phase 设置为 Failed。</p>

<h2 id="3-initcontainer">3. initContainer</h2>

<p>https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</p>

<p>Pod 可以包含多个容器，应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。Init 容器与普通的容器非常像，除了如下两点：</p>

<ul>
  <li>总是运行到完成，总是顺序执行到结束。</li>
  <li>每个都必须在下一个启动之前成功完成。</li>
</ul>

<p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 值为 Never，它不会重新启动。</p>

<p>指定容器为 Init 容器，需要在 Pod 的 spec 中添加 initContainers 字段， 该字段內以Container 类型对象数组的形式组织，和应用的 containers 数组同级相邻。 Init 容器的状态在 status.initContainerStatuses 字段中以容器状态数组的格式返回（类似 status.containerStatuses 字段）。</p>

<h3 id="31-与普通容器的不同之处">3.1. 与普通容器的不同之处</h3>

<p>Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 但是，Init 容器对资源请求和限制的处理稍有不同。给定Init 容器的执行顺序下，资源使用适用于如下规则：</p>

<ul>
  <li>所有 Init 容器上定义的任何特定资源的 limit 或 request 的最大值，作为 Pod <em>有效初始 request/limit</em></li>
  <li>Pod 对资源的有效 limit/request是如下两者的较大者：
    <ul>
      <li>所有应用容器对某个资源的 limit/request 之和</li>
      <li>对某个资源的有效初始 limit/request</li>
    </ul>
  </li>
  <li>基于有效 limit/request 完成调度，这意味着 Init 容器能够为初始化过程预留资源，这些资源在 Pod 生命周期过程中并没有被使用。</li>
  <li>Pod 的 <em>有效 QoS 层</em> ，与 Init 容器和应用容器的一样。</li>
</ul>

<p>配额和限制适用于有效 Pod的 limit/request。 Pod 级别的 cgroups 是基于有效 Pod 的 limit/request，和调度器相同。</p>

<p>同时 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。</p>

<p>如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时，Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。</p>

<h3 id="32-init容器能做什么">3.2. init容器能做什么？</h3>

<p>因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</p>

<ul>
  <li>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，没有必要仅为了在安装过程中使用类似 <code class="highlighter-rouge">sed</code>、 <code class="highlighter-rouge">awk</code>、 <code class="highlighter-rouge">python</code> 或 <code class="highlighter-rouge">dig</code> 这样的工具而去<code class="highlighter-rouge">FROM</code> 一个镜像来生成一个新的镜像。</li>
  <li>Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。</li>
  <li>应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</li>
  <li>Init 容器能以不同于Pod内应用容器的文件系统视图运行。因此，Init容器可具有访问 <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</a> 的权限，而应用容器不能够访问。</li>
  <li>由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。一旦前置条件满足，Pod内的所有的应用容器会并行启动。</li>
</ul>

<h3 id="33-使用-init-容器">3.3. 使用 Init 容器</h3>

<p>下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 <code class="highlighter-rouge">myservice</code> 启动，第二个等待 <code class="highlighter-rouge">mydb</code> 启动。 一旦这两个 Init容器 都启动完成，Pod 将启动<code class="highlighter-rouge">spec</code>区域中的应用容器。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-pod</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">myapp</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-container</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">echo</span><span class="nv"> </span><span class="s">The</span><span class="nv"> </span><span class="s">app</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">running!</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600'</span><span class="pi">]</span>
  <span class="na">initContainers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">init-myservice</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s2">"</span><span class="s">until</span><span class="nv"> </span><span class="s">nslookup</span><span class="nv"> </span><span class="s">myservice.$(cat</span><span class="nv"> </span><span class="s">/var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">waiting</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">myservice;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">2;</span><span class="nv"> </span><span class="s">done"</span><span class="pi">]</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">init-mydb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s2">"</span><span class="s">until</span><span class="nv"> </span><span class="s">nslookup</span><span class="nv"> </span><span class="s">mydb.$(cat</span><span class="nv"> </span><span class="s">/var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">waiting</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">mydb;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">2;</span><span class="nv"> </span><span class="s">done"</span><span class="pi">]</span>
</code></pre></div></div>

<p>下面的 yaml 文件展示了 <code class="highlighter-rouge">mydb</code> 和 <code class="highlighter-rouge">myservice</code> 两个 Service：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myservice</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="s">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="s">9376</span>
<span class="nn">---</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mydb</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="s">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="s">9377</span>
</code></pre></div></div>

<p>要启动这个 Pod，可以执行如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl apply <span class="nt">-f</span> myapp.yaml
pod/myapp-pod created
</code></pre></div></div>

<p>要检查其状态：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get <span class="nt">-f</span> myapp.yaml
NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre></div></div>

<p>如需更详细的信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe <span class="nt">-f</span> myapp.yaml
Name:          myapp-pod
Namespace:     default
<span class="o">[</span>...]
Labels:        <span class="nv">app</span><span class="o">=</span>myapp
Status:        Pending
<span class="o">[</span>...]
Init Containers:
  init-myservice:
<span class="o">[</span>...]
    State:         Running
<span class="o">[</span>...]
  init-mydb:
<span class="o">[</span>...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
<span class="o">[</span>...]
Containers:
  myapp-container:
<span class="o">[</span>...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
<span class="o">[</span>...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  <span class="nt">---------</span>    <span class="nt">--------</span>    <span class="nt">-----</span>    <span class="nt">----</span>                      <span class="nt">-------------</span>                           <span class="nt">--------</span>      <span class="nt">------</span>        <span class="nt">-------</span>
  16s          16s         1        <span class="o">{</span>default-scheduler <span class="o">}</span>                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        <span class="o">{</span>kubelet 172.17.4.201<span class="o">}</span>    spec.initContainers<span class="o">{</span>init-myservice<span class="o">}</span>     Normal        Pulling       pulling image <span class="s2">"busybox"</span>
  13s          13s         1        <span class="o">{</span>kubelet 172.17.4.201<span class="o">}</span>    spec.initContainers<span class="o">{</span>init-myservice<span class="o">}</span>     Normal        Pulled        Successfully pulled image <span class="s2">"busybox"</span>
  13s          13s         1        <span class="o">{</span>kubelet 172.17.4.201<span class="o">}</span>    spec.initContainers<span class="o">{</span>init-myservice<span class="o">}</span>     Normal        Created       Created container with docker id 5ced34a04634<span class="p">;</span> Security:[seccomp<span class="o">=</span>unconfined]
  13s          13s         1        <span class="o">{</span>kubelet 172.17.4.201<span class="o">}</span>    spec.initContainers<span class="o">{</span>init-myservice<span class="o">}</span>     Normal        Started       Started container with docker id 5ced34a04634
</code></pre></div></div>

<p>如需查看Pod内 Init 容器的日志，请执行:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl logs myapp-pod <span class="nt">-c</span> init-myservice <span class="c"># Inspect the first init container</span>
<span class="nv">$ </span>kubectl logs myapp-pod <span class="nt">-c</span> init-mydb      <span class="c"># Inspect the second init container</span>
</code></pre></div></div>

<p>在这一刻，Init 容器将会等待至发现名称为<code class="highlighter-rouge">mydb</code>和<code class="highlighter-rouge">myservice</code>的 Service。</p>

<p>创建<code class="highlighter-rouge">mydb</code>和<code class="highlighter-rouge">myservice</code>的 service 命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> services.yaml
service <span class="s2">"myservice"</span> created
service <span class="s2">"mydb"</span> created
</code></pre></div></div>

<p>这样你将能看到这些 Init容器 执行完毕，随后<code class="highlighter-rouge">my-app</code>的Pod转移进入 Running 状态：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get <span class="nt">-f</span> myapp.yaml
NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre></div></div>

<p>一旦我们启动了 <code class="highlighter-rouge">mydb</code> 和 <code class="highlighter-rouge">myservice</code> 这两个 Service，我们能够看到 Init 容器完成，并且 <code class="highlighter-rouge">myapp-pod</code> 被创建</p>

<h3 id="34-启动过程">3.4. 启动过程</h3>

<p>在 Pod 启动过程中，每个Init 容器在网络和数据卷初始化之后会按顺序启动。每个 Init容器 成功退出后才会启动下一个 Init容器。 如果因为运行或退出时失败引发容器启动失败，它会根据 Pod 的 restartPolicy 策略进行重试。 然而，如果 Pod 的 restartPolicy 设置为 Always，Init 容器失败时会使用 restartPolicy 的 OnFailure 策略。</p>

<p>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态。 Init 容器的端口将不会在 Service 中进行聚集。 正在初始化中的 Pod 处于 Pending 状态，但会将条件 Initializing 设置为 true。</p>

<p>如果 Pod 重启，所有 Init 容器必须重新执行。</p>

<p>对 Init 容器 spec 的修改仅限于容器的 image 字段。 更改 Init 容器的 image 字段，等同于重启该 Pod。</p>

<p>因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，基于 EmptyDirs 写文件的代码，应该对输出文件可能已经存在做好准备。</p>

<p>Init 容器具有应用容器的所有字段。 然而 Kubernetes 禁止使用 readinessProbe，因为 Init 容器不能定义不同于完成（completion）的就绪（readiness）。 这一点会在校验时强制执行。</p>

<p>在 Pod 上使用 activeDeadlineSeconds和在容器上使用 livenessProbe 可以避免 Init 容器一直重复失败。 activeDeadlineSeconds 时间包含了 Init 容器启动的时间。</p>

<p>在 Pod 中的每个应用容器和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在校验时抛出错误。</p>

<h2 id="4-容器探针probe">4. 容器探针Probe</h2>

<h3 id="41-什么是探针">4.1. 什么是探针</h3>

<p>探针Probe是由 kubelet对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三种类型的处理程序：</p>

<ul>
  <li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
  <li>TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li>
  <li>HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</li>
</ul>

<p>每次探测都将获得以下三种结果之一：</p>

<ul>
  <li>成功：容器通过了诊断。</li>
  <li>失败：容器未通过诊断。</li>
  <li>未知：诊断失败，因此不会采取任何行动。</li>
</ul>

<p>Kubelet 可以选择是否执行在容器上运行的三种探针执行和做出反应：</p>

<ul>
  <li><code class="highlighter-rouge">livenessProbe</code>：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到<code class="highlighter-rouge">重启策略</code>的影响。如果容器不提供存活探针，则默认状态为 <code class="highlighter-rouge">Success</code>。</li>
  <li><code class="highlighter-rouge">readinessProbe</code>：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 <code class="highlighter-rouge">Failure</code>。如果容器不提供就绪探针，则默认状态为 <code class="highlighter-rouge">Success</code>。</li>
  <li><code class="highlighter-rouge">startupProbe</code>: 指示容器中的应用是否已经启动。如果提供了启动探测(startup probe)，则禁用所有其他探测，直到它成功为止。如果启动探测失败，kubelet 将杀死容器，容器服从其重启策略进行重启。如果容器没有提供启动探测，则默认状态为成功<code class="highlighter-rouge">Success</code>。</li>
</ul>

<p>PodSpec 中有一个 <code class="highlighter-rouge">restartPolicy</code> 字段，可能的值为 Always、OnFailure 和 Never。默认为 Always。 <code class="highlighter-rouge">restartPolicy</code> 适用于 Pod 中的所有容器。<code class="highlighter-rouge">restartPolicy</code> 仅指通过同一节点上的 kubelet 重新启动容器。失败的容器由 kubelet 以五分钟为上限的指数退避延迟（10秒，20秒，40秒…）重新启动，并在成功执行十分钟后重置。Pod一旦绑定到一个节点，他将永远不会重新绑定到另一个节点。</p>

<h3 id="42-该什么时候使用探针">4.2. 该什么时候使用探针?</h3>

<ul>
  <li>
    <p>liveness probe</p>

    <p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针; kubelet 将根据 Pod 的<code class="highlighter-rouge">restartPolicy</code> 自动执行正确的操作。</p>

    <p>如果您希望容器在探测失败时被杀死并重新启动，那么请指定一个存活探针，并指定<code class="highlighter-rouge">restartPolicy</code> 为 Always 或 OnFailure。</p>
  </li>
  <li>
    <p>readiness probe</p>

    <p>如果要仅在探测成功时才开始向 Pod 发送流量，请指定就绪探针。在这种情况下，就绪探针可能与存活探针相同，但是 spec 中的就绪探针的存在意味着 Pod 将在没有接收到任何流量的情况下启动，并且只有在探针探测成功后才开始接收流量。</p>

    <p>如果希望容器能够自行维护，您可以指定一个就绪探针，该探针检查与存活探针不同的端点。</p>

    <p>需要注意的是，如果只想在 Pod 被删除时能够拒绝连接（drain request），则不一定需要使用就绪探针；在删除 Pod 时，Pod 会自动将自身置于未完成状态，无论就绪探针是否存在。当等待 Pod 中的容器停止时，Pod 仍处于未完成状态。</p>
  </li>
  <li>
    <p>startup probe（1.16 alpha）</p>
  </li>
</ul>

<h3 id="43-定义探针">4.3. 定义探针</h3>

<ul>
  <li>
    <p>定义存活的命令（liveness）</p>

    <p>许多长时间运行的应用程序最终会过渡到断开的状态，除非重新启动，否则无法恢复。Kubernetes 提供了存活探测器来发现并补救这种情况。</p>

    <p>在这篇练习中，会创建一个 Pod，其中运行一个基于 <code class="highlighter-rouge">k8s.gcr.io/busybox</code> 镜像的容器。下面是这个 Pod 的配置文件。</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">test</span><span class="pi">:</span> <span class="s">liveness</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">liveness-exec</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">liveness</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">k8s.gcr.io/busybox</span>
    <span class="na">args</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">/bin/sh</span>
    <span class="pi">-</span> <span class="s">-c</span>
    <span class="pi">-</span> <span class="s">touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span>
    <span class="na">livenessProbe</span><span class="pi">:</span>
      <span class="na">exec</span><span class="pi">:</span>
        <span class="na">command</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">cat</span>
        <span class="pi">-</span> <span class="s">/tmp/healthy</span>
      <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="s">5</span>
      <span class="na">periodSeconds</span><span class="pi">:</span> <span class="s">5</span>
</code></pre></div>    </div>

    <p>在这个配置文件中，可以看到 Pod 中只有一个容器。<code class="highlighter-rouge">periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。<code class="highlighter-rouge">initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。kubelet 在容器内执行命令 <code class="highlighter-rouge">cat /tmp/healthy</code> 来进行探测。如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p>

    <p>当容器启动时，执行如下的命令：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/sh <span class="nt">-c</span> <span class="s2">"touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600"</span>
</code></pre></div>    </div>

    <p>这个容器生命的前 30 秒， <code class="highlighter-rouge">/tmp/healthy</code> 文件是存在的。所以在这最开始的 30 秒内，执行命令 <code class="highlighter-rouge">cat /tmp/healthy</code> 会返回成功码。30 秒之后，执行命令 <code class="highlighter-rouge">cat /tmp/healthy</code> 就会返回失败码。</p>

    <p>创建 Pod：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl apply <span class="nt">-f</span> https://k8s.io/examples/pods/probe/exec-liveness.yaml
</code></pre></div>    </div>

    <p>在 30 秒内，查看 Pod 的事件：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe pod liveness-exec
</code></pre></div>    </div>

    <p>输出结果显示还没有存活探测器失败：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
<span class="nt">---------</span> <span class="nt">--------</span>    <span class="nt">-----</span>   <span class="nt">----</span>            <span class="nt">-------------</span>           <span class="nt">--------</span>    <span class="nt">------</span>      <span class="nt">-------</span>
24s       24s     1   <span class="o">{</span>default-scheduler <span class="o">}</span>                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Pulling     pulling image <span class="s2">"k8s.gcr.io/busybox"</span>
23s       23s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Pulled      Successfully pulled image <span class="s2">"k8s.gcr.io/busybox"</span>
23s       23s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Created     Created container with docker id 86849c15382e<span class="p">;</span> Security:[seccomp<span class="o">=</span>unconfined]
23s       23s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Started     Started container with docker id 86849c15382e
</code></pre></div>    </div>

    <p>35 秒之后，再来看 Pod 的事件：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe pod liveness-exec
</code></pre></div>    </div>

    <p>在输出结果的最下面，有信息显示存活探测器失败了，这个容器被杀死并且被重建了。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
<span class="nt">---------</span> <span class="nt">--------</span>    <span class="nt">-----</span>   <span class="nt">----</span>            <span class="nt">-------------</span>           <span class="nt">--------</span>    <span class="nt">------</span>      <span class="nt">-------</span>
37s       37s     1   <span class="o">{</span>default-scheduler <span class="o">}</span>                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Pulling     pulling image <span class="s2">"k8s.gcr.io/busybox"</span>
36s       36s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Pulled      Successfully pulled image <span class="s2">"k8s.gcr.io/busybox"</span>
36s       36s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Created     Created container with docker id 86849c15382e<span class="p">;</span> Security:[seccomp<span class="o">=</span>unconfined]
36s       36s     1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   <span class="o">{</span>kubelet worker0<span class="o">}</span>   spec.containers<span class="o">{</span>liveness<span class="o">}</span>   Warning     Unhealthy   Liveness probe failed: <span class="nb">cat</span>: can<span class="s1">'t open '</span>/tmp/healthy<span class="s1">': No such file or directory
</span></code></pre></div>    </div>

    <p>再等另外 30 秒，检查看这个容器被重启了：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pod liveness-exec
</code></pre></div>    </div>

    <p>输出结果显示 <code class="highlighter-rouge">RESTARTS</code> 的值增加了 1。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre></div>    </div>
  </li>
  <li>
    <p>定义就绪探针readiness</p>

    <p>有时候，应用程序会暂时性的不能提供通信服务。例如，应用程序在启动时可能需要加载很大的数据或配置文件，或是启动后要依赖等待外部服务。在这种情况下，既不想杀死应用程序，也不想给它发送请求。Kubernetes 提供了就绪探测器来发现并缓解这些情况。容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。</p>

    <p>就绪探测器的配置和存活探测器的配置相似。唯一区别就是要使用 <code class="highlighter-rouge">readinessProbe</code> 字段，而不是 <code class="highlighter-rouge">livenessProbe</code> 字段。</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">readinessProbe</span><span class="pi">:</span>
  <span class="na">exec</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">cat</span>
    <span class="pi">-</span> <span class="s">/tmp/healthy</span>
  <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="s">5</span>
  <span class="na">periodSeconds</span><span class="pi">:</span> <span class="s">5</span>
</code></pre></div>    </div>

    <p>HTTP 和 TCP 的就绪探测器配置也和存活探测器的配置一样的。</p>

    <p>就绪和存活探测可以在同一个容器上并行使用。两者都用可以确保流量不会发给还没有准备好的容器，并且容器会在它们失败的时候被重新启动。</p>
  </li>
</ul>

<h3 id="44-probe的配置选项">4.4. Probe的配置选项</h3>

<p><strong>探测器</strong>有很多配置字段，可以使用这些字段精确的控制存活和就绪检测的行为：</p>

<ul>
  <li><code class="highlighter-rouge">initialDelaySeconds</code>：容器启动后要等待多少秒后存活和就绪探测器才被初始化，默认是 0 秒，最小值是 0。</li>
  <li><code class="highlighter-rouge">periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
  <li><code class="highlighter-rouge">timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
  <li><code class="highlighter-rouge">successThreshold</code>：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。存活探测的这个值必须是 1。最小值是 1。</li>
  <li><code class="highlighter-rouge">failureThreshold</code>：当 Pod 启动了并且探测到失败，Kubernetes 的重试次数。存活探测情况下的放弃就意味着重新启动容器。就绪探测情况下的放弃 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>

<p><strong>HTTP 探测器</strong>可以在 <code class="highlighter-rouge">httpGet</code> 上配置额外的字段：</p>

<ul>
  <li><code class="highlighter-rouge">host</code>：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 “Host” 来代替。</li>
  <li><code class="highlighter-rouge">scheme</code> ：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 HTTP。</li>
  <li><code class="highlighter-rouge">path</code>：访问 HTTP 服务的路径。</li>
  <li><code class="highlighter-rouge">httpHeaders</code>：请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li>
  <li><code class="highlighter-rouge">port</code>：访问容器的端口号或者端口名。如果数字必须在 1 ～ 65535 之间。</li>
</ul>

<p>对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的路径和端口来执行检测。除非 <code class="highlighter-rouge">httpGet</code> 中的 <code class="highlighter-rouge">host</code> 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。如果 <code class="highlighter-rouge">scheme</code> 字段设置为了 <code class="highlighter-rouge">HTTPS</code>，kubelet 会跳过证书验证发送 HTTPS 请求。大多数情况下，不需要设置<code class="highlighter-rouge">host</code> 字段。这里有个需要设置 <code class="highlighter-rouge">host</code> 字段的场景，假设容器监听 127.0.0.1，并且 Pod 的 <code class="highlighter-rouge">hostNetwork</code> 字段设置为了 <code class="highlighter-rouge">true</code>。那么 <code class="highlighter-rouge">httpGet</code> 中的 <code class="highlighter-rouge">host</code> 字段应该设置为 127.0.0.1。可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 <code class="highlighter-rouge">host</code> 字段，而是应该在 <code class="highlighter-rouge">httpHeaders</code> 中设置 <code class="highlighter-rouge">Host</code>。</p>

<p>对于一次 TCP 探测，kubelet 在节点上（不是在 Pod 里面）建立探测连接，这意味着你不能在 <code class="highlighter-rouge">host</code> 参数上配置 service name，因为 kubelet 不能解析 service name。</p>

<h2 id="5-pod-readinessggate114-stable">5. Pod readinessgGate（1.14 stable）</h2>

<p>可以把外部的回复信息或者信号注入到我们的应用当中，使用Pod readiness。我们需要在Pod的spec文件中定义<code class="highlighter-rouge">readinessGates</code>，并且在其中定义一些条件，供kubelet来判定pod是否就绪。</p>

<p>readinessGates会根据<code class="highlighter-rouge">status.condition</code>的状态来判定，如果kubernetes不能够在pod中找到<code class="highlighter-rouge">status.conditons</code>中的字段，而<code class="highlighter-rouge">condition</code>的默认状态是<code class="highlighter-rouge">False</code></p>

<p>例如：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="nn">...</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">readinessGates</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">conditionType</span><span class="pi">:</span> <span class="s2">"</span><span class="s">www.example.com/feature-1"</span>
<span class="na">status</span><span class="pi">:</span>
  <span class="na">conditions</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Ready</span>                              <span class="c1"># a built in PodCondition</span>
      <span class="na">status</span><span class="pi">:</span> <span class="s2">"</span><span class="s">False"</span>
      <span class="na">lastProbeTime</span><span class="pi">:</span> <span class="no">null</span>
      <span class="na">lastTransitionTime</span><span class="pi">:</span> <span class="s">2018-01-01T00:00:00Z</span>
    <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">www.example.com/feature-1"</span>        <span class="c1"># an extra PodCondition</span>
      <span class="na">status</span><span class="pi">:</span> <span class="s2">"</span><span class="s">False"</span>
      <span class="na">lastProbeTime</span><span class="pi">:</span> <span class="no">null</span>
      <span class="na">lastTransitionTime</span><span class="pi">:</span> <span class="s">2018-01-01T00:00:00Z</span>
  <span class="na">containerStatuses</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerID</span><span class="pi">:</span> <span class="s">docker://abcd...</span>
      <span class="na">ready</span><span class="pi">:</span> <span class="no">true</span>
<span class="nn">...</span>
</code></pre></div></div>

<h2 id="6-pod-重启的原因">6. Pod 重启的原因</h2>

<p>Pod重启导致 Init 容器重新执行，主要有如下几个原因：</p>

<ul>
  <li>用户更新 Pod 的 Spec 导致 Init 容器镜像发生改变。Init 容器镜像的变更会引起 Pod 重启. 应用容器镜像的变更仅会重启应用容器。</li>
  <li>Pod 的基础设施容器 (译者注：如 pause 容器) 被重启。 这种情况不多见，必须由具备 root 权限访问 Node 的人员来完成。</li>
  <li>当 <code class="highlighter-rouge">restartPolicy</code> 设置为 Always，Pod 中所有容器会终止而强制重启，由于垃圾收集导致 Init 容器的完成记录丢失。</li>
</ul>

<p>你可以在Pod的规格信息中与containers数组同级的位置指定 Init 容器。</p>


    <div class="tags">
        
    </div>


<div id="commento"></div>
<script src="https://cdn.commento.io/js/commento.js"></script>
<noscript>Please enable JavaScript to load the comments.</noscript>



</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2020 原生云技术. All rights reserved. <br />
 Site last generated: Jun 29, 2020 <br />
<p><img src="images/company_logo.png" alt="Company logo"/></p>
                </div>
            </div>
</footer>


        </div>
    <!-- /.row -->
</div>
<!-- /.container -->
</div>
<!-- /#main -->
    </div>

</body>

</html>
