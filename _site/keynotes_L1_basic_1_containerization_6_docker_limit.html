<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Docker镜像管理基础 | cloudnative365.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Docker镜像管理基础" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/keynotes_L1_basic_1_containerization_6_docker_limit.html" />
<meta property="og:url" content="http://localhost:4000/keynotes_L1_basic_1_containerization_6_docker_limit.html" />
<meta property="og:site_name" content="cloudnative365.github.io" />
<script type="application/ld+json">
{"headline":"Docker镜像管理基础","url":"http://localhost:4000/keynotes_L1_basic_1_containerization_6_docker_limit.html","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=481468f1311b237dbb8ec4fec8c1099b04cbcc76">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">cloudnative365.github.io</a></h1>
      

      <h2 id="限制容器的资源">限制容器的资源</h2>
<p>容器默认是没有资源限制的，可以使用宿主机内核调度给他的所有的资源。Docker提供了一种方式，可以控制容器使用多少内存，CPU和Block IO，需要在使用docker run的时候提供运行时的提供参数。
我们前面说过，CPU是可压缩资源，而Memory是不可压缩资源。</p>

<h3 id="memory">Memory</h3>
<ul>
  <li>在linux主机上，进程启动的时候，如果内核检测到内存不足以运行了，就会抛出一个OOME，叫做Out Of Memory Exception，然后就开始杀死其他进程。在杀进程的时候会挑选内存hogs，找优先级比较低的进程杀，如果优先级一样，那么就会随机杀进程。一旦发生OOME，任何进程都有可能被杀死，包括docker daemon在内。所以，Docker特意调整了docker daemon的OOM优先级，以避免被杀死，但是容器的优先级是没有被调整过的。那么，那些进程是应该被杀死的呢，其实每个进程都有一个OOM_SCORE，然后排序，从上到下先把得分最高的杀死，如果不够，继续杀。而在OOM_SCORE的标准当中有一个OOM_ADJ，就是OOM的权重，也可以简单理解为优先级，这个级别越低，越不容易被杀死，而docker daemon就是调整了这个参数。</li>
  <li>下面的选项就描述了怎样限制内存</li>
</ul>

<p><img src="https://graph.baidu.com/resource/2227ed44727c8fbda3c2001586501742.png" alt="file" /></p>

<ul>
  <li>在内存级别，我们有两个维度去限制，一个是物理内存，一个是虚拟内存。实际上的量级，我们可以使用k，m，g来限制，而例子中是4m。</li>
  <li>如果我们要使用–memory-swap选项，就必须设置-m选项，而memory swap也有一些选项，比如正数，0，没设置和-1</li>
</ul>

<p><img src="https://graph.baidu.com/resource/222b092ad5932e79db12501586503855.png" alt="file" /></p>

<p>而他们的关系可以看下面的表</p>

<p><img src="https://graph.baidu.com/resource/22275c550106331084f4701586509017.png" alt="file" /></p>

<ul>
  <li>最后，我们防止程序被oom kill的时候需要使用–oom-kill-disable选项或者–oom-score-adj选项</li>
</ul>

<h3 id="cpu">CPU</h3>
<ul>
  <li>而CPU默认也是没有限制的</li>
  <li>我们还是需要通过参数来配置CPU的周期，下面的参数就是怎样限制内存</li>
</ul>

<p><img src="https://graph.baidu.com/resource/222ef562a80737dd745ac01586501936.png" alt="file" /></p>

<ul>
  <li>
    <p>大多数系统都是使用CFS来调度的，CFS，一般来说，每个进程运行都需要一个CPU，但是如果进程的数量大于CPU的数量，我们进程运行的时候的优先级就需要进程调度器来决定这个就是CFS（完全公平调度算法），他决定的是进程在【100-139】之间的数值，数值越低级别越高。那么我们在对于应用分类的时候，会把应用分成两类，一个是CPU密集型的，一个是IO密集型的。对于CPU密集型的，我们要尽量调低他的优先级，因为只要被调度到CPU上，他就尽可能的消耗CPU的时间。我们内核上有一些算法，会对那些对于CPU占用时间较长的程序做一些惩罚措施，动态调底他的优先级。而对于那些starve的程序，由于很长时间没有被调度到CPU，就会适当调高他的优先级。</p>
  </li>
  <li>
    <p>在Docker1.13或者更高的版本，我们还可以配置实时调度策略【0-99】，这个都是内核级别的调度器，数值越高，级别越高</p>
  </li>
  <li>
    <p>一般限制有三种方式</p>
    <ul>
      <li>–cpus是指可以sh使用多少个核，比如1.5个核，如果我们系统上有4核CPU，那么只要满足使用1.5个核就可以了，不一定会被调度到那个核心上，</li>
      <li>如果想指定核心，就需要使用–cpuset-cpus选项</li>
      <li>最后一种方式是指定压缩比例的方式 –cpu-shares</li>
    </ul>
  </li>
</ul>

<h3 id="压测工具stress">压测工具stress</h3>
<p>我们可以使用dockerhub上一个专门测试容器的镜像叫stress</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> stress <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">-m</span> 256m lorel/docker-stress-ng:latest stress <span class="nt">--vm</span> 2
docker run <span class="nt">--name</span> stress <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--cpus</span> 2 orel/docker-stress-ng:latest stress <span class="nt">--cpu</span> 8
docker run <span class="nt">--name</span> stress <span class="nt">-it</span> <span class="nt">--rm</span> lorel/docker-stress-ng:latest stress <span class="nt">--cpu</span> 8
docker run <span class="nt">--name</span> stress <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--cpuset-cpus</span> 0,2 lorel/docker-stress-ng:latest stress <span class="nt">--cpu</span> 8
docker run <span class="nt">--name</span> stress <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--cpu-shares</span> 1024 lorel/docker-stress-ng:latest stress <span class="nt">--cpu</span> 8
</code></pre></div></div>
<p>然后我们可以使用<code class="highlighter-rouge">docker top</code>和<code class="highlighter-rouge">docker stat</code>命令来追踪系统资源的使用</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
