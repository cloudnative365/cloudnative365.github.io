---
title: 设计Kubernetes资源
keywords: keynotes, L2_advanced, 1_kubernetes, 3_CKAD, 4_Design
permalink: keynotes_L2_advanced_1_kubernetes_3_CKAD_4_Design.html
sidebar: keynotes_L2_advanced_sidebar
typora-copy-images-to: ./pics/4_Design
typora-root-url: ../../../../../../cloudnative365.github.io

---

## 1. 课程目标

+ 定义一个应用的资源清单
+ 理解多容器Pod的设计模式：sidecar，adapter，ambassador
+ 讨论应用设计的概念

## 2. 设计Kubernetes资源

### 2.1. 传统应用架构

在生产系统中实现Kubernetes最大的障碍就是要根据现有的应用环境去设计。最佳的Kubernetes部署的设计比简单的容器化一个应用要复杂的多。在传统的应用构建和部署的时候，进程之间的耦合性旺旺非常强。

比如，Apache网站服务基本不允许一些定制化的功能。所以，服务器本身和应用被无缝的绑在了一起。随着需求的增加，应用会被迁移到更大的服务器上。我们假设构建和维护服务器的时候，实例必须不能停止，并且他和其他资源（存储和网络）也高度的集成。

在早期的容器使用当中，应用在容器化的时候，是不需要重新部署的。这就到这了资源在失败之后，升级之后或者重新配置之后的一些问题。费用和重新设计的时候的一些意见分歧，还有重新部署的成本都需要考虑进去

### 2.2. 资源的解耦

资源的解耦对于Kubernetes是必须要做的事情。在某个实例的整个生命周期中，应用不使用专用的端口和套接字，这么做的目的就是为了让每个功能和他依赖的资源解耦。软件的整个期望向着每个组件都可以被移除，代替或者重新构建整个目标靠拢。

我们一般不会把某个资源写死在一个应用里面，我们会用调度的资源，就好像Service，启用链接和重新链接的方式来提供更灵活的服务。独立的机器已经不能满足应用和用户的需求了，特定数量的系统需要整合在一起来满足特定的需求。

随着Kubernetes的逐渐成熟，有更多的资源被开发出来，这些资源也非常容易的被部署。同时，kubernetes的开发者也在优化特定的功能，使得我们在设计的时候不用过多考虑其他的对象。

### 2.3. 临时性

与解耦同样重要的是临时性。我们希望有新的功能上线的时候，其他的组件不会也因为这个组件的更新而意外终止，或者需要重新构建。所有的资源对于其他资源的调用都应该是一次性的，这样的话我们就可以轻松的升级版本或者横向扩展。

直接升级并不一定是最好的选择，因为没法保证剩下的应用是可用的。控制器通常会终止一个容器，然后去部署一个新的容器去取代原来的位置，当然，新的容器是和原来容器不一样的版本或者设置。通常，传统的应用都不是用这种方式开发的，没有为长远的设计而考虑。

### 2.4. 灵活的架构

就像是一群鱼，或者可以想象成一个pod的鲸鱼，很多独立的资源在一起工作，但是彼此是不会相互影响的，而且永远不会依赖其他的鲸鱼，这样就是灵活的，高可用的，和容易扩展的。不使用巨大的apache服务器，我们可以部署很多灵活的nginx服务器，每个都处理一小部分的请求。这样同样可以达到目的，并且设计的好处是使得每个nginx处理的请求都不相同。

一个解耦的，灵活的，而且临时性的框架并不是最效率的。为了让Kubernetes的编排功能起作用，我们需要一些的agents，就想控制器，或者是一个守护进程，他持续的监控目前集群的状态和做变更，直到状态满足我们的要求。

目前硬件的商业趋势是使用多个小型的服务器来代替一个巨大的系统。

### 2.5. 管理资源的使用

怎样限制节点的CPU，内存和root文件系统存储的使用

### 2.6. 使用标签选择器

### 2.7. 多容器的Pod

一个容器中有多个容器这种架构，和我们尽量解耦的思想是相违背的。在容器内部运行整个的操作系统，会丢掉Kubernetes在细粒度的扩展性。但是，如果我们有特殊的需求，一定需要运行第二个或者第三个容器来辅助主容器的做法的可行的。额外添加第二个容器，每个容器都可以被充分利用，且保持开发的独立性和扩展性，在适当的时候还可以用来分担一部分的压力。

### 2.8. Sidecar，Adapter和Ambassador模式

+ **sidecar**：当我们需要添加一些主容器中没有的功能的时候，我们会使用sidecar模式，这样既不会改变原有程序的代码，添加一些部署中不需要的东西，我们的容器还可以扩展原有容器的功能，并且保持了解耦和扩展性。就比如Prometheus监控和Fluentd日志收集的sidecar。
+ **adapter**：这种容器的作用是修改入栈和出栈的数据来满足我们其他的需求。举例来说，我们有一个非常专业的监控系统，这个监控系统的数据格式要求非常特殊。想获得这种格式化之后的数据，我们通常会借助adapter模式，这是最有效的方式去格式化主容器所产生的监控数据，而不是去修改监控系统本身或者已经容器化的应用。adapter容器用来把多种应用都输出成统一的格式。
+ **Ambassador**：这有两重含义，一个是指微服务架构上的API gateway模式，比如Istio，spring cloud gateway或者是更早的Zuul这类微服务治理相关软件所使用的模式，他们不使用kubenetes自身提供的代理功能，而是使用容器内部的代理来转发请求。我们以后讲Istio的时候再说这类微服务治理相关的知识。而另一重含义就是软件 ambassador，他同样是一款微服务治理软件，和Linkerd一样，都是这类软件的后期之秀。